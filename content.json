{"meta":{"title":"msnodevLog","subtitle":"아직 익숙하지 않다면 두번이상 개발하는","description":"대부분의 개발자들 처럼 이것저것 아무거나 다 손대보고 익숙해지는게 최선인 것 같다. 그렇다면 한 번이 아닌 두 번이상 개발을 해보며 익숙해 지는게 공부같다.","author":"Myeong Seok KIM","url":"https://msnodeve.github.io","root":"/"},"pages":[{"title":"about","date":"2020-03-08T05:33:14.000Z","updated":"2020-03-08T05:52:02.708Z","comments":true,"path":"about/index.html","permalink":"https://msnodeve.github.io/about/index.html","excerpt":"","text":"Intro김명석 입니다. Github Contribution CoerfolioCoer 는 제가 지은 별명입니다.대학을 오고 함께 프로젝트를 하는 스스로의 모습을보며 협력하다의 Co와 –하는 사람의 –er를 생각해 만든별명입니다.다양한 분야에 관심이 많고, 넓게 보려고 노력하는개발자 김명석 코어폴리오를 소개합니다."},{"title":"all-archives","date":"2020-03-08T06:06:26.735Z","updated":"2020-03-08T06:06:26.735Z","comments":false,"path":"all-archives/index.html","permalink":"https://msnodeve.github.io/all-archives/index.html","excerpt":"","text":""},{"title":"all-categories","date":"2020-03-08T06:07:24.098Z","updated":"2020-03-08T06:07:24.098Z","comments":false,"path":"all-categories/index.html","permalink":"https://msnodeve.github.io/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2020-03-08T06:07:35.300Z","updated":"2020-03-08T06:07:35.300Z","comments":false,"path":"all-tags/index.html","permalink":"https://msnodeve.github.io/all-tags/index.html","excerpt":"","text":""}],"posts":[{"title":"운영체제의 구조","slug":"os-structure","date":"2020-07-03T05:04:20.000Z","updated":"2020-07-03T05:48:46.750Z","comments":true,"path":"2020/07/03/os-structure/","link":"","permalink":"https://msnodeve.github.io/2020/07/03/os-structure/","excerpt":"운영체제의 구조운영체제 구조","text":"커널과 인터페이스 커널 프로세스 관리, 메모리 관리, 저장장치 관리와 같은 운영체제의 핵심적인 기능을 모아놓은 것운영체제의 성능은 커널이 좌우함 운영체제는 크게 두 부분으로 나뉨 이미지의 출처는 구글 이미지 검색에서 가져왔음을 밝힙니다. 시스템 호출과 디바이스 드라이버 시스템 호출 커널이 자신을 보호하기 위한 인터페이스커널이 제공하는 시스템 관련 서비스를 모아놓은 것(함수형태로 제공)사용자나 응용 프로그램으로부터 컴퓨터의 자원을 보호하기 위해 자원에 직접 접근하는 것을 차단 API? 응용프로그램이 자신과 연관된 프로그램을 만들 수 있도록 제공하는 인터페이스 SDK? 프로그램 개발자를 위해 API 및 API 사용메뉴얼 뿐만아니라 프로그램 개발에 필요한 코드 편집기와 에뮬레이터 같은 각종 개발용 응용 프로그램까지 하나로 묶어서 배포하는 개발 툴 드라이버 커널과 하드웨어의 인터페이스를 담당마우스, 키보드와 같이 복잡하지 않은 디바이스 드라이버는 커널에 포함되어 있지만, 크래픽카드, 프린터와 같이 크기가 크고 복잡한 디바이스 드라이버는 사용자가 직접 설치해야함 커널의 구성 핵심 기능 설명 프로세스 관리 프로세스에 CPU를 배분하고 작업에 필요한 제반 환경을 제공 메모리 관리 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간을 제공 파일 시스템 관리 데이터를 저장하고 접근할 수 있는 인터페이스를 제공 입출력 관리 필요한 입력과 출력 서비스를 제공 프로세스 간 통신 관리 공동 작업을 위한 각 프로세스 간 통신 환경을 지원 단일형 구조 커널 초창기의 운영체제 구조구분 없이 핵심 기능을 하나로 구성MS-DOS, VMS, 초기의 운영체제들이 대표적 장점 모듈이 거의 분리되지 않았기 때문에 모듈 간의 통신 비용이 줄어들어 효율적인 운영이 가능 단점 모듈이 하나로 묶여있기 때문에 버그나 오류를 처리하기 어려움상호 의존성이 높기 때문에 기능상의 작은 결함이 시스템의 전체로 확산될 위험다양한 환경의 시스템에 적용이 어려움 계층형 구조 커널 단일형 구조 커널이 발전된 커널비슷한 모듈을 묶어서 하나의 계층으로 만들고 계층 간의 통신을 통해 운영체제의 구현하는 방식모듈화로 인해 버그 및 오류를 쉽게 처리가 가능마이크로소프트의 윈도우를 비롯한 운영체제는 대부분 이 구조로 이루어짐 마이크로 구조 커널 프로세스 관리, 메모리 관리, 프로세스 간 통신 관리 등 가장 기본적인 기능만 제공사용자 영역에 많은 부분이 구현되어 있음각 모듈은 세분화되어 존재하며 모듈 간의 정보 교환은 프로세스 간 통신을 통해 이루어짐각 모듈은 독립적으로 작동하기 때문에 하나의 모듈이 실패해도 전체 운영체제가 멈추지 않는다.커널이 가벼워, CPU 용량이 작은 시스템에도 적용이 가능","categories":[{"name":"os","slug":"os","permalink":"https://msnodeve.github.io/categories/os/"},{"name":"structure","slug":"os/structure","permalink":"https://msnodeve.github.io/categories/os/structure/"}],"tags":[{"name":"Operating System","slug":"operating-system","permalink":"https://msnodeve.github.io/tags/operating-system/"},{"name":"OS","slug":"os","permalink":"https://msnodeve.github.io/tags/os/"},{"name":"Structure","slug":"structure","permalink":"https://msnodeve.github.io/tags/structure/"}]},{"title":"운영체제의 역사","slug":"os-history","date":"2020-07-02T08:32:57.000Z","updated":"2020-07-02T09:34:14.148Z","comments":true,"path":"2020/07/02/os-history/","link":"","permalink":"https://msnodeve.github.io/2020/07/02/os-history/","excerpt":"운영체제의 역사운영체제 역사","text":"키워드로 한번 알아 보도록 하자초창기 컴퓨터(1940년대)최초의 컴퓨터 에니악, 30톤 규모의 거대한 계산기로 미사일 탄도를 계산하기 위해 제작물론 운영체제가 없었음 초기의 컴퓨터 키보드, 마우스, 모니터와 같은 주변장치가 없었다. 하드와이어링 전선을 연결하여 논리회로를 구성하는 것 일괄 작업 시스템(1950년대)현대적인 모습의 컴퓨터가 탄생 미약하지만 중앙처리장치 CPU 와 메인메모리 RAM가 존재키보드, 마우스, 모니터와 같은 입력 및 출력장치가 없었음 입력장치 천공 카드리더, 카드에 구멍을 뚫어 문자를 입력 출력장치 라인 프린터, 한 번에 한 줄씩 출력 일괄 작업 시스템, 일괄 처리 시스템 모든 작업을 한꺼번에 처리해야 하고 프로그램 실행 중간에 사용자가 데이터를 입력하거나 수정하는 것이 불가능 대화형 시스템(1960년대 초반) 키보드와 모니터가 등장이로써 작업 중간에 사용자가 입력, 중간 결과값을 볼 수 있게 되었음 대화형 시스템 컴퓨터와 사용자의 대화를 통해 작업이 이루어지는 시스템 CPU 집중 작업 일괄 작업 시스템에서 프로그램이 실행되는 동안 입출력이 불가능하기 때문에 대부분의 작업이 CPU만 사용하는 계산 작업 입출력 집중 작업 대화형 시스템에서 프로그램이 실행되는 동안 입출력이 가능하기 때문에 입출력 집중작업이 생겨남 시분할 시스템(1960년대 후반) 다중 프로그래밍이 가능하게 되는 시점CPU 사용 시간을 아주 잘게 쪼개어 여러 작업에 나누어 줌 시분할 시스템 여러 작업을 조금씩 처리하여 작업이 동시에 이루어지는 것처럼 보이게 하는 것오늘날의 컴퓨터에 대부분 사용 타임 슬라이스, 타임 퀀텀 잘게 나뉜 시간 한 조각 실시간 시스템 특정 시스템에서 일정 시간 안에 작업이 처리되도록 보장 분산 시스템(1970년대 후반) 스티브 잡스가 최초의 개인용 컴퓨터 애플II를 발표개인이 소유하기 쉬워짐인터넷이 등장한 시기TCP/IP 프로토콜이 정의됨 운영체제 애플의 매킨토시마이크로소프트의 MS-DOS가 많이 사용됨 분산 시스템 네트워크상에 분산되어 있는 여러 컴퓨터로 작업을 처리하고 그 결과를 상호 교환하도록 구성한 시스템 클라이언트/서버 시스템(1990년대~현재) 분산 시스템은 시스템에 참가하는 모든 컴퓨터가 동일한 지위이기 때문에 컴퓨터가 고장나거나 추가되면 작업을 분배하고 모으기 쉽지않다이런 문제점을 해결 웹 시스템 클라이언트가 요청하고, 서버는 요청받은 작업을 응답해주는 이중 구조 문제점 서버 과부하를 문제점으로 볼 수 있음수십만 명의 클라이언트를 처리하기 위해서는 많은 서버와 큰 용량의 네트워크가 필요함 그리드 컴퓨팅 분산 시스템의 한 분야로, 서로 다른 기종의 컴퓨터들을 묶어 대용량의 컴퓨터 풀을 구성하고 이를 원격지와 연결하여 대용량 연산을 수행하는 컴퓨팅 환경예) 웹하드 서비스, 무료로 웹 하드 이용권을 나누어주는 것은 서비스 가입자 몰래 그리드 딜리버리 프로그램을 깔아서 서버의 부하를 줄이기 위함이게 무슨 말이냐 하면 서버에있는 데이터를 내려 받는게 아니라 이미 내려받은 컴퓨터로부터 몰래 데이터를 빼와서 전달하는 것내 컴퓨터 자원을 빼앗기기 싫다면 사용 금지 SaaS(Software as a Service) 사용자가 필요할 때 소프트웨어 기능을 이용하고 그 만큼만 비용을 지불하는 개념 클라우드 컴퓨팅 언제 어디서나 응용 프로그램과 데이터를 자유롭게 사용할 수 있는 컴퓨팅 환경으로그리드 컴퓨팅 + SaaS","categories":[{"name":"os","slug":"os","permalink":"https://msnodeve.github.io/categories/os/"},{"name":"history","slug":"os/history","permalink":"https://msnodeve.github.io/categories/os/history/"}],"tags":[{"name":"Operating System","slug":"operating-system","permalink":"https://msnodeve.github.io/tags/operating-system/"},{"name":"OS","slug":"os","permalink":"https://msnodeve.github.io/tags/os/"},{"name":"History","slug":"history","permalink":"https://msnodeve.github.io/tags/history/"}]},{"title":"SpringBoot Database 활용하기(3) - [Backend Framework]","slug":"springboot-step03-springboot-data","date":"2020-06-21T04:07:45.000Z","updated":"2020-06-21T04:17:27.807Z","comments":true,"path":"2020/06/21/springboot-step03-springboot-data/","link":"","permalink":"https://msnodeve.github.io/2020/06/21/springboot-step03-springboot-data/","excerpt":"세번째 단계 Database 연결 및 활용하기이번 포스트에서는 Database 연결 및 MyBatis 활용에 대해서 알아 보도록 하겠습니다. Database MyBatis SpringBoot MySQL","text":"INDEX Backend SpringBoot 프로젝트 생성 및 실행 해보기(1) Backend SpringBoot REST API 만들기(2) 세번째 단계 Database 연결 및 활용하기 Branch Name예제 브랜치 이름은 다음과 같습니다.step03-springboot-data SpringBoot와 Database 연동을 해보자 API를 사용자에게 지속적으로 제공하기 위해서는 영속적인 저장소가 필요합니다.따라서 RDBMS(Relational Database Management System)에 속하는 제품을 사용합니다. 의존성 제외 설정 src/main/resources 폴더 밑에 application.properties 파일을 생성합니다. application.properties 에 다음 줄을 추가합니다. 1spring.main.web-environment=false build.gradle에 필요한 라이브러리를 추가합니다. 버전을 다시 고쳤습니다. 복붙해주세요. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152plugins &#123; id 'java' id 'org.springframework.boot' version '1.5.8.RELEASE'&#125;ext&#123; springBootVersion='1.5.8.RELEASE'&#125;sourceCompatibility = 1.8targetCompatibility = 1.8sourceSets&#123; main&#123; java &#123; srcDir 'src/main/java' &#125; resources&#123; srcDir 'src/resources' &#125; &#125;&#125;repositories &#123; jcenter()&#125;dependencies &#123; compile 'org.springframework.boot:spring-boot-starter-web' compile \"org.springframework.boot:spring-boot-devtools\" compile 'org.slf4j:slf4j-api:1.7.7' testCompile 'junit:junit:4.12' compile group: 'org.springframework.boot', name: 'spring-boot-starter-hateoas', version: '2.1.5.RELEASE' compile group: 'io.springfox', name: 'springfox-swagger2', version: '2.9.2' compile group: 'io.springfox', name: 'springfox-swagger-ui', version: '2.9.2' compile group: 'org.hsqldb', name: 'hsqldb', version:'2.3.2' compile \"org.springframework.boot:spring-boot-starter-data-jpa:$&#123;springBootVersion&#125;\" compile group: 'org.hibernate', name: 'hibernate-validator', version: '4.2.0.Final' compile group: 'javax.el', name: 'javax.el-api', version: '3.0.0' compile group: 'javax.validation', name: 'validation-api', version: '1.0.0.GA' //capcha compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-imaging', version: '1.1' compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-simplecaptcha', version: '1.1'&#125; 데이터 저장소로는 hsqldb를 사용하며, 이는 소형 관계형 데이터베이스 엔진의 일종으로 JDBC를 지원하고, 라이브러리 추가만으로 사용가능해서 로컬 개발시에 많이 쓰입니다. Database Object Mapping값 매핑 src/main/java/seok/model 패키지 밑에 일반 사용자와 관리자 구분을 하는 UserRole.java Enum 클래스를 하나 생성합니다. 123456package seok.model;public enum UserRole &#123; USER, // 0 ADMIN // 1&#125; UserEntity 클래스를 만들어 보자 src/main/java/seok/model 패키지 밑에 UserEntity.java 클래스를 생성합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package seok.model;import javax.persistence.*;import java.util.Date;@Entitypublic class UserEntity &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private Integer age; private Date created; @Column(name=\"role\") @Enumerated(EnumType.ORDINAL) private UserRole role; @PrePersist public void beforeCreate()&#123; created = new Date(); &#125; public UserEntity() &#123; &#125; public UserEntity(String name, Integer age, UserRole role) &#123; this.name = name; this.age = age; this.role = role; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getCreated() &#123; return created; &#125; public void setCreated(Date created) &#123; this.created = created; &#125; @Override public String toString() &#123; return \"UserEntity&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", age=\" + age + \", created=\" + created + \", role=\" + role + '&#125;'; &#125;&#125; @Entity(데이터베이스 스키마의 내용을 자바 클래스로 표현할 수 있는 대상) 어노테이션을 선언함으로써 엔티티 매니저가 관리해야 할 대상임을 명시합니다. @Enumerated 어노테이션 속성으로 @EnumType을 지정할 때, ORDINAL로 하면 값이 int로 할당 되며 STRING으로 지정하면 ENUM의 이름으로 할당 됩니다. User Repository 인터페이스를 생성하자 src/main/java/seok 패키지 밑에 repository 패키지를 생성 후, UserRepository.java 인터페이스를 생성합니다. 1234567891011package seok.repository;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.repository.query.Param;import org.springframework.stereotype.Repository;import seok.model.UserEntity;@Repositorypublic interface UserRepository extends JpaRepository&lt;UserEntity, Long&gt; &#123; UserEntity findByName(@Param(\"name\") String name);&#125; 필드를 검색하기 위해 다음과 같이 사용할 수 있습니다. 1반환 타입 findBy 필드명(파라미터); 실행 결과 보기 application.properties 에 spring.main.web-environment=false 를 설정해줬기 때문에 웹은 실행되지않고, 종료합니다. Database Server와 연동MySQL 설치MySQL DB 설치하기 각 환경에 맞는 서버를 설치합니다. MySQL WorkBench 도 설치하면 좋을 것 같습니다. Database, Table 생성하기 1create database exam; exam 이라는 데이터베이스를 하나 생성합니다. 12345create table tbl_user( id varchar(40) not null, username varchar(45) not null, password varchar(45) not null); user 정보 테이블을 생성합니다. Database Connection Pool HikariCP 사용하기build.gradle 라이브러리 추가합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253plugins &#123; id 'java' id 'idea' id 'org.springframework.boot' version '1.5.8.RELEASE'&#125;ext&#123; springBootVersion='1.5.8.RELEASE'&#125;sourceCompatibility = 1.8targetCompatibility = 1.8sourceSets&#123; main&#123; java &#123; srcDir 'src/main/java' &#125; resources&#123; srcDir 'src/resources' &#125; &#125;&#125;repositories &#123; jcenter()&#125;dependencies &#123; compile 'org.springframework.boot:spring-boot-starter-web' compile \"org.springframework.boot:spring-boot-devtools\" compile 'org.slf4j:slf4j-api:1.7.7' testCompile 'junit:junit:4.12' compile group: 'org.springframework.boot', name: 'spring-boot-starter-hateoas', version: '2.1.5.RELEASE' compile group: 'io.springfox', name: 'springfox-swagger2', version: '2.9.2' compile group: 'io.springfox', name: 'springfox-swagger-ui', version: '2.9.2' compile group: 'org.springframework.boot', name: 'spring-boot-starter-jdbc', version: '2.3.0.RELEASE' compile group: 'com.zaxxer', name: 'HikariCP', version: '2.5.1' compile group: 'org.mybatis.spring.boot', name: 'mybatis-spring-boot-starter', version: '1.3.0' compile group: 'mysql', name: 'mysql-connector-java', version: '8.0.13' //capcha compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-imaging', version: '1.1' compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-simplecaptcha', version: '1.1'&#125; application.properties 에 MySQL DB 서버 정보를 설정합니다. 123456spring.datasource.driverClassName=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/exam?serverTimezone=UTC&amp;useUniCode=yes&amp;characterEncoding=UTF-8spring.datasource.username=ssafyspring.datasource.password=ssafymybatis.config-location=classpath:mybatis-config.xml Mybitis와 MySQL 연동 src/main/resources 아래 다음 파일을 생성합니다. 123456789&lt;!-- mybatis-config.xml --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;mappers&gt; &lt;mapper resource=\"mappers/userMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 12345678910111213141516171819202122232425262728293031323334&lt;!-- userMapper.xml --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"user\"&gt; &lt;insert id=\"insertUser\"&gt; insert into tbl_user(id, username, password) value (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;) &lt;/insert&gt; &lt;select id=\"selectAll\" resultType=\"seok.model.User\"&gt; select id, username, password from tbl_user &lt;/select&gt; &lt;select id=\"select\" resultType=\"seok.model.User\"&gt; select id, username, password from tbl_user where id = #&#123;id&#125; &lt;/select&gt; &lt;update id=\"update\"&gt; update tbl_user set username = #&#123;username&#125;, password = #&#123;password&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;delete id=\"delete\"&gt; delete from tbl_user where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; MVC 패턴으로 패키지 구성하기 위 그림과 같이 파일을 구성 합니다. 1234567891011121314151617package seok.repository;import seok.model.User;import java.util.List;public interface UserRepository &#123; public List&lt;User&gt; selectAll() throws Exception; public User select(String id) throws Exception; public int insert(User user) throws Exception; public int update(User user) throws Exception; public int delete(String id) throws Exception;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package seok.repository;import org.apache.ibatis.session.SqlSession;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import seok.model.User;import java.util.List;@Repositorypublic class UserRepositoryImpl implements UserRepository &#123; private static final String MAPPER_NAME_SPACE = \"user.\"; @Autowired SqlSession sqlSession; @Override public List&lt;User&gt; selectAll() throws Exception &#123; return sqlSession.selectList(MAPPER_NAME_SPACE + \"selectAll\"); &#125; @Override public User select(String id) throws Exception &#123; return sqlSession.selectOne(MAPPER_NAME_SPACE + \"select\", id); &#125; @Override public int insert(User user) throws Exception &#123; return sqlSession.insert(MAPPER_NAME_SPACE + \"insertUser\", user); &#125; @Override public int update(User user) throws Exception &#123; return sqlSession.update(MAPPER_NAME_SPACE + \"update\", user); &#125; @Override public int delete(String id) throws Exception &#123; return sqlSession.delete(MAPPER_NAME_SPACE + \"delete\", id); &#125;&#125; 1234567891011121314151617package seok.service;import seok.model.User;import java.util.List;public interface UserService &#123; public List&lt;User&gt; findAllUsers() throws Exception; public User findByUserId(String id) throws Exception; public int registry(User user) throws Exception; public int modify(User user) throws Exception; public int remove(String id) throws Exception;&#125; 123456789101112131415161718192021222324252627282930313233343536373839package seok.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import seok.model.User;import seok.repository.UserRepository;import java.util.List;@Servicepublic class UserServiceImpl implements UserService&#123; @Autowired UserRepository repository; @Override public List&lt;User&gt; findAllUsers() throws Exception &#123; return repository.selectAll(); &#125; @Override public User findByUserId(String id) throws Exception &#123; return repository.select(id); &#125; @Override public int registry(User user) throws Exception &#123; return repository.insert(user); &#125; @Override public int modify(User user) throws Exception &#123; return repository.update(user); &#125; @Override public int remove(String id) throws Exception &#123; return repository.delete(id); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package seok.controller;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;import seok.model.User;import seok.service.UserService;import java.util.List;@RestController@RequestMapping(value = \"/api\")@Api(value=\"msnodeve\")public class UserController &#123; @Autowired UserService service; @GetMapping(\"/user\") @ApiOperation(value = \"모든 유저의 정보를 반환한다.\", response = List.class) public ResponseEntity&lt;List&lt;User&gt;&gt; findAllUsers() &#123; List&lt;User&gt; users = null; try &#123; users = service.findAllUsers(); &#125; catch (Exception e) &#123; e.printStackTrace(); return new ResponseEntity&lt;&gt;(null, HttpStatus.NO_CONTENT); &#125; return new ResponseEntity&lt;&gt;(users, HttpStatus.OK); &#125; @GetMapping(\"/user/&#123;id&#125;\") @ApiOperation(value = \"유저의 정보를 반환한다.\", response = Object.class) public ResponseEntity&lt;User&gt; findByUserId(@PathVariable String id) &#123; User user = null; try &#123; user = service.findByUserId(id); &#125; catch (Exception e) &#123; e.printStackTrace(); return new ResponseEntity&lt;&gt;(null, HttpStatus.NO_CONTENT); &#125; return new ResponseEntity&lt;&gt;(user, HttpStatus.OK); &#125; @PostMapping(\"/user\") @ApiOperation(value = \"유저의 정보를 입력한다.\", response = String.class) public ResponseEntity&lt;String&gt; registryUser(@RequestBody User user) &#123; try &#123; if (service.registry(user) != 0) return new ResponseEntity&lt;&gt;(\"성공적으로 등록되었습니다.\", HttpStatus.CREATED); else return new ResponseEntity&lt;&gt;(\"등록 실패했습니다.\", HttpStatus.BAD_REQUEST); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return new ResponseEntity&lt;&gt;(\"등록 실패했습니다.\", HttpStatus.BAD_REQUEST); &#125; @PutMapping(\"/user\") @ApiOperation(value = \"유저의 정보를 수정한다.\", response = String.class) public ResponseEntity&lt;String&gt; modifyUser(@RequestBody User user) &#123; try &#123; if (service.modify(user) != 0) return new ResponseEntity&lt;&gt;(\"성공적으로 수정되었습니다.\", HttpStatus.OK); else return new ResponseEntity&lt;&gt;(\"수정 실패했습니다.\", HttpStatus.BAD_REQUEST); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return new ResponseEntity&lt;&gt;(\"수정 실패했습니다.\", HttpStatus.BAD_REQUEST); &#125; @DeleteMapping(\"/user/&#123;id&#125;\") @ApiOperation(value = \"유저의 정보를 삭제한다.\", response = String.class) public ResponseEntity&lt;String&gt; removeUser(@PathVariable String id) &#123; try &#123; if (service.remove(id) != 0) return new ResponseEntity&lt;&gt;(\"성공적으로 삭제되었습니다.\", HttpStatus.OK); else return new ResponseEntity&lt;&gt;(\"삭제 실패했습니다.\", HttpStatus.BAD_REQUEST); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return new ResponseEntity&lt;&gt;(\"삭제 실패했습니다.\", HttpStatus.BAD_REQUEST); &#125;&#125; 실행해보기 등록하기 DB 결과 INDEX Backend SpringBoot 프로젝트 생성 및 실행 해보기(1) Backend SpringBoot REST API 만들기(2)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"spring","slug":"backend/framework/spring","permalink":"https://msnodeve.github.io/categories/backend/framework/spring/"},{"name":"springboot","slug":"backend/framework/spring/springboot","permalink":"https://msnodeve.github.io/categories/backend/framework/spring/springboot/"},{"name":"database","slug":"backend/framework/spring/springboot/database","permalink":"https://msnodeve.github.io/categories/backend/framework/spring/springboot/database/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Spring","slug":"spring","permalink":"https://msnodeve.github.io/tags/spring/"},{"name":"SpringBoot","slug":"springboot","permalink":"https://msnodeve.github.io/tags/springboot/"},{"name":"Database","slug":"database","permalink":"https://msnodeve.github.io/tags/database/"}]},{"title":"SpringBoot REST API 만들기(2) - [Backend Framework]","slug":"springboot-step02-make-rest-api","date":"2020-06-20T10:03:02.000Z","updated":"2020-06-22T01:50:51.596Z","comments":true,"path":"2020/06/20/springboot-step02-make-rest-api/","link":"","permalink":"https://msnodeve.github.io/2020/06/20/springboot-step02-make-rest-api/","excerpt":"두번째 단계 REST API 만들기이번 포스트에서는 REST API를 만드는 방법을 알아 보도록 하겠습니다. 스프링부트 SpringBoot IntelliJ Framework REST API","text":"INDEX Backend SpringBoot 프로젝트 생성 및 실행 해보기(1) Backend SpringBoot Database 활용하기(3) 두번째 단계 Make REST API Branch Name예제 브랜치 이름은 다음과 같습니다.step02-make-rest-api REST의 특성 클라이언트/서버 클라이언트와 서버가 서로 독립적으로 구분 되어야 한다. 또한 서버 또는 클라이언트 증설 시 서로간의 의존성 때문에 확장에 문제가 되서는 안된다. 상태 없음 서버는 클라이언트의 상태를 기억할 필요가 없다. 레이어드 아키텍처 다계층 형태로 레이어를 추가하거나 수정, 제거 할 수 있고 확장성이 있어야한다. 캐시 클라이언트가 캐시를 통해서 응답을 재사용 하여 이를 통해 서버의 부하를 낮춰 서버의 성능이 향상 될 수 있다. 코드 온 디멘드 요청이 오면 코드를 준다. REST 인터페이스 규칙 리소스 식별 웹 안에서 URI와 같은 고유 식별자를 통해 표현한다. 표현을 통한 리소스 처리 JSON, XML, HTML 페이지와 같이 다양한 유형으로 표현 할 수 있다. 자기 묘사 메세지 HTTP 통신 할 때 Http header에 메타 데이터 정보를 추가해서 실제 데이터와는 관련 없지만 데이터에 대한 설명을 나타내는 정보를 담을 수 있다. 애플리케이션 상태 하이퍼미디어(HATEOAS) REST API를 개발할 때도 단순히 데이터만 전달하는 것이 아닌 링크 정보까지 포함한다. REST API 만들기모델 클래스 만들기데이터를 담을 수 있는 클래스를 만듭니다. src/main/java/seok/model 경로를 만들고, 그 밑에 Todo.java 를 생성 Todo.java 내용은 다음과 같습니다. 123456789101112131415161718192021222324252627package seok.model;public class Todo &#123; private int id; private String title; public Todo(int id, String title) &#123; this.id = id; this.title = title; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125;&#125; 컨트롤러 클래스 만들기URL을 요청하면 Todo 클래스의 인스턴스를 생성해 JSON으로 보여줄 수 있는 컨트롤러를 만듭니다. src/main/java/seok/controller 경로 밑에 TodoController.java 를 생성 TodoController.java 내용은 다음과 같습니다. 123456789101112131415161718package seok.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import seok.model.Todo;import java.util.concurrent.atomic.AtomicInteger;@RestController@RequestMapping(value = \"/todo\")public class TodoController &#123; private final AtomicInteger counter = new AtomicInteger(); @RequestMapping(\"/todo\") public Todo todo()&#123; return new Todo(counter.incrementAndGet(), \"코딩하기\"); &#125;&#125; AtomicInteger는 Atomic(더 이상 쪼개질 수 없는 성질)을 의미하며, 단순히 Integer 타입으로 선언한다면 서로 다른 Thread 에서 하나의 변수에 대해 값을 쓰거나 읽기 때문에 문제가 발생할 수 있지만, AtomicInteger를 쓰므로 Thread-safe 하게 처리가 가능합니다. 실행해보기localhost:8080/todo/todo 를 계속 호출해보면 호출 할 때마다 숫자가 정상적으로 증가하는 것을 확인 할 수 있습니다. REST API에서 HTTP Method 사용컨트롤러 메서드에 POST 매핑TodoController.java 에 POST 메서드를 만듭니다. 1234@PostMapping(\"/todo\")public Todo registryTodo(@RequestParam(value=\"todoTitle\") String todoTitle)&#123; return new Todo(counter.incrementAndGet(), todoTitle);&#125; /todo/todo를 엔드 포인트로 합니다. GET은 Body 가 없어서 URL을 직접 호출 할 수 있지만, POST는 요청의 몸체가 되므로 도구를 사용해서 테스트 해봐야합니다. 여기서는 Postman를 사용하도록 하겠습니다. Postman 설치하기 위와 같이 실행하면 결과값을 받아 볼 수 있습니다. 응답 헤더 활용하기ResponseEntity 클래스는 HttpEntity를 상속받은 클래스로 Http 응답에 대한 상태값을 표현 할 수 있습니다. TodoController.java 에 다음 코드를 추가합니다. 1234@PostMapping(\"/todo/response\")public ResponseEntity&lt;Todo&gt; postRegistryTodo(@RequestParam String todoTitle)&#123; return new ResponseEntity&lt;&gt;(new Todo(counter.incrementAndGet(), todoTitle), HttpStatus.CREATED);&#125; 결과를 받아보면 Status: 201 Created 라는 결과를 받아 볼 수 있습니다. HATEOAS를 사용한 URI 정보 표현하기HATEOAS 설정build.gradle 파일에 다음 라이브러리를 추가합니다. 123dependencies &#123; compile 'org.springframework.boot:spring-boot-starter-hateoas'&#125; ResourceSupport 클래스를 상속받을 모델 클래스 TodoResource.java를 만들도록 하겠습니다. 1234567891011121314151617181920212223package seok.model;import org.springframework.hateoas.ResourceSupport;public class TodoResource extends ResourceSupport &#123; private String title; public TodoResource() &#123; &#125; public TodoResource(String title) &#123; this.title = title; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125;&#125; Controller에 다음을 추가하도록 하겠습니다. 1234567891011import static org.springframework.hateoas.mvc.ControllerLinkBuilder.linkTo;import static org.springframework.hateoas.mvc.ControllerLinkBuilder.methodOn;...@PostMapping(\"/todo/hateoas\")public ResponseEntity&lt;TodoResource&gt; resourceResponseEntity(@RequestParam String todoTitle)&#123; TodoResource todoResource = new TodoResource(todoTitle); todoResource.add(linkTo(methodOn(TodoController.class).resourceResponseEntity(todoTitle)).withSelfRel()); return new ResponseEntity&lt;&gt;(todoResource, HttpStatus.OK);&#125; todoResource 인스턴스를 생성한 후에 링크 정보 추가를 위해서 linkTo 메서드로 TodoController 클래스의 resourceResponseEntity 메서드를 매핑후, withSelfRel 메서드를 이용해 URL 정보를 만들고 add메서드로 정보를 추가했습니다. 결과는 다음과 같습니다. REST API 문서화 API를 제공하려면 가이드 문서 제공이 필수적인데, 개발할 때 마다 별도의 문서를 작성하고 업데이트하는 것은 비용이 많이 듭니다. 따라서 Swagger 를 이용해서 API를 설명하는 페이지를 자동 생성하는 방법을 알아 보도록 하겠습니다. Swagger 라이브러리 추가build.gradle에 springfox-swagger2, springfox-swagger-ui을 추가합니다. dependencies의 라이브러리들을 최신, 가장많이 사용하는 라이브러리들로 좀 교체했습니다.build.gradle의 전체 내용은 다음과 같습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344plugins &#123; id 'java' id 'org.springframework.boot' version '2.2.2.RELEASE'&#125;ext&#123; springBootVersion='2.2.2.RELEASE'&#125;sourceCompatibility = 1.8targetCompatibility = 1.8sourceSets&#123; main&#123; java &#123; srcDir 'src/main/java' &#125; resources&#123; srcDir 'src/resources' &#125; &#125;&#125;repositories &#123; jcenter()&#125;dependencies &#123; compile group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '2.2.2.RELEASE' compile group: 'org.springframework.boot', name: 'spring-boot-devtools', version: '2.0.4.RELEASE' compile group: 'org.springframework.boot', name: 'spring-boot-starter-hateoas', version: '2.1.5.RELEASE' compile group: 'io.springfox', name: 'springfox-swagger2', version: '2.9.2' compile group: 'io.springfox', name: 'springfox-swagger-ui', version: '2.9.2' compile 'org.slf4j:slf4j-api:1.7.7' testCompile 'junit:junit:4.12' //capcha compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-imaging', version: '1.1' compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-simplecaptcha', version: '1.1'&#125; SwaggerConfiguration 클래스 만들기 src/main/java/seok/configuration 패키지 생성 후 SwaggerConfiguration.java 클래스를 생성합니다. 12345678910111213141516171819202122232425262728293031323334package seok.configuration;import com.google.common.base.Predicate;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;import static com.google.common.base.Predicates.or;import static springfox.documentation.builders.PathSelectors.regex;@Configuration@EnableSwagger2public class SwaggerConfiguration &#123; @Bean public Docket postsApi() &#123; return new Docket(DocumentationType.SWAGGER_2).groupName(\"public-api\") .apiInfo(apiInfo()).select().paths(postPaths()).build(); &#125; private Predicate&lt;String&gt; postPaths() &#123; return or(regex(\"/todo/.*\")); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder().title(\"TODO API\") .description(\"Todo REST API 개발 문서\") .license(\"msnodeve License\") .licenseUrl(\"msnodeve@gmail.com\").version(\"1.0\").build(); &#125;&#125; 123private Predicate&lt;String&gt; postPaths() &#123; return or(regex(\"/todo/.*\"));&#125; 해당 부분은 컨트롤러의 기본 URI 가 todo로 시작하기 때문에 /todo만 인식하도록 설정을 추가한 것 입니다. 실행해보기http://localhost:8080/swagger-ui.html#/ 로 접속을 해보면 지금까지 작성해온 API가 UI로 표시되는 모습을 확인 할 수 있습니다. 각 메서드의 별도 동작은 한번씩 작동 시켜보길 바랍니다. INDEX Backend SpringBoot 프로젝트 생성 및 실행 해보기(1) Backend SpringBoot Database 활용하기(3)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"spring","slug":"backend/framework/spring","permalink":"https://msnodeve.github.io/categories/backend/framework/spring/"},{"name":"springboot","slug":"backend/framework/spring/springboot","permalink":"https://msnodeve.github.io/categories/backend/framework/spring/springboot/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Spring","slug":"spring","permalink":"https://msnodeve.github.io/tags/spring/"},{"name":"SpringBoot","slug":"springboot","permalink":"https://msnodeve.github.io/tags/springboot/"}]},{"title":"SpringBoot 프로젝트 생성 및 실행 해보기(1) - [Backend Framework]","slug":"springboot-stop01-create-project-run","date":"2020-06-10T12:07:48.000Z","updated":"2020-06-22T01:50:39.991Z","comments":true,"path":"2020/06/10/springboot-stop01-create-project-run/","link":"","permalink":"https://msnodeve.github.io/2020/06/10/springboot-stop01-create-project-run/","excerpt":"첫번째 단계 프로젝트 생성하기이번 포스트에서는 IntelliJ 개발환경에서 SpringBoot Framework 프로젝트를 생성하고 실행해보는 시간을 가져 보도록 하겠습니다. 스프링부트 SpringBoot IntelliJ Framework 프로젝트 생성하는 방법!","text":"INDEX Backend SpringBoot REST API 만들기(2) Backend SpringBoot Database 활용하기(3) 첫번째 단계 Make Project Branch Name예제 브랜치 이름은 다음과 같습니다.step01-make-project 1. IntelliJ로 Spring Boot 프로젝트 만들기 file → New → Project 를 클릭해서 새로운 프로젝트를 생성 New Project의 유형 중에서 Gradle을 선택하고 Next 버튼을 클릭 프로젝트 이름과 프로젝트가 저장될 로컬 디렉터리, 패키지명 지정 Ok, apply suggestion! 을 클릭 2. Spring Boot에 대한 이해자바 기반에서 개발을 진행할 때 결과 파일 포맷은 크게 두 가지로 구분하며 로컬에서 실행되는 JAR, 웹 애플리케이션 컨테이너에서 실행되는 WAR입니다. Spring Boot에서 웹 자원들을 실행하기 위한 규약 위와 같이 폴더를 생성 웹 자원들을 각 규약에 맞는 곳에 두면 웹을 위한 별도의 폴더를 만들지 않고 사용이 가능합니다. Gradle을 이용한 Spring Boot 설정build.gradle 파일에서 Spring Boot 플러그인을 사용 할 수 있도록 설정하는데, 여기서 의존성을 추가하도록 합니다. build.gradle 파일의 전체 내용은 다음과 같습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546plugins &#123; id 'java' id 'org.springframework.boot' version '1.5.8.RELEASE'&#125;ext&#123; springBootVersion='1.5.8.RELEASE'&#125;sourceCompatibility = 1.8targetCompatibility = 1.8sourceSets&#123; main&#123; java &#123; srcDir 'src/main/java' &#125; resources&#123; srcDir 'src/resources' &#125; &#125;&#125;repositories &#123; jcenter()&#125;dependencies &#123; compile 'org.springframework.boot:spring-boot-starter-web' compile \"org.springframework.boot:spring-boot-starter-thymeleaf\" compile \"org.springframework.boot:spring-boot-devtools\" compile group: 'org.webjars', name: 'webjars-locator', version: '0.32' compile 'org.webjars:jquery:3.1.0' compile 'org.webjars:bootstrap:3.3.1' compile 'org.webjars:materializecss:0.96.0' compile 'org.slf4j:slf4j-api:1.7.7' testCompile 'junit:junit:4.12' //capcha compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-imaging', version: '1.1' compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-simplecaptcha', version: '1.1'&#125; Controller 만들기 src/main/java/seok/controller 경로를 만들고, 그 밑에 HomeController.java 를 생성 HomeController.java의 전체는 다음과 같습니다. 123456789101112package seok.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HomeController &#123; @RequestMapping(\"/\") public String hello() &#123; return \"hello\"; &#125;&#125; 배포 시에 root-context를 / 로 설정할 것이므로 http://localhost:8080 을 입력 했을 때 hello 가 출력되도록 합니다. Controller를 사용하는 Main 클래스 만들기 src/main/java/seok 경로 아래에 Main 클래스를 생성 SpringBootApiMainApplication.java 의 전체 내용은 다음과 같습니다. 1234567891011package seok;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringBootApiMainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootApiMainApplication.class, args); &#125;&#125; @SpringBootApplication 어노테이션의 역할 @ComponentScan(basePadkages = “seok.controller”) @Configuration @EnableAutoConfiguration 의 세 가지 어노테이션을 @SpringBootApplication 어노테이션으로 대체 할 수 있습니다. 실행하는 방법 2가지 SpringBootApiMainApplication.java 를 우클릭 하고 Run Terminal 탭을 열어 ./gradlew bootRun 명령어 실행 (참고로 해당 terminal은 git bash로 실행 중) 실행하게 되면 다음과 같은 로그를 볼 수 있습니다. 1234567891011121314151617181920212223오후 7:01:11: Executing task &#39;SpringBootApiMainApplication.main()&#39;...&gt; Task :compileJava UP-TO-DATE&gt; Task :processResources NO-SOURCE&gt; Task :classes UP-TO-DATE&gt; Task :SpringBootApiMainApplication.main()... . ____ _ __ _ _ &#x2F;\\\\ &#x2F; ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\&#x2F; _&#96; | \\ \\ \\ \\ \\\\&#x2F; ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | &#x2F; &#x2F; &#x2F; &#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|_|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|___&#x2F;&#x3D;&#x2F;_&#x2F;_&#x2F;_&#x2F; :: Spring Boot :: (v1.5.8.RELEASE)...2020-06-06 19:01:17.135 INFO 18752 --- [ restartedMain] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2020-06-06 19:01:17.203 INFO 18752 --- [ restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2020-06-06 19:01:17.208 INFO 18752 --- [ restartedMain] seok.SpringBootApiMainApplication : Started SpringBootApiMainApplication in 3.963 seconds (JVM running for 4.709) 이제 브라우저를 열어 localhost:8080 을 입력해봅니다. INDEX Backend SpringBoot REST API 만들기(2) Backend SpringBoot Database 활용하기(3)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"spring","slug":"backend/framework/spring","permalink":"https://msnodeve.github.io/categories/backend/framework/spring/"},{"name":"springboot","slug":"backend/framework/spring/springboot","permalink":"https://msnodeve.github.io/categories/backend/framework/spring/springboot/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Spring","slug":"spring","permalink":"https://msnodeve.github.io/tags/spring/"},{"name":"SpringBoot","slug":"springboot","permalink":"https://msnodeve.github.io/tags/springboot/"}]},{"title":"LIS(최장 증가 수열) - [Algorithm Skill]","slug":"algorithm-lis","date":"2020-05-24T03:36:30.000Z","updated":"2020-05-24T08:04:24.158Z","comments":true,"path":"2020/05/24/algorithm-lis/","link":"","permalink":"https://msnodeve.github.io/2020/05/24/algorithm-lis/","excerpt":"알고리즘의 기본적인 스킬을 다룹니다.이번 포스트에서는 알고리즘의 스킬 중 LIS(최장 증가 수열)에 대해서 알아 보려고 합니다. DP 보다 효율적인 탐색 방법 Binary Search","text":"알고리즘의 기본적인 스킬을 다룹니다.이번 포스트에서는 알고리즘의 스킬 중 LIS(최장 증가 수열)에 대해서 알아 보려고 합니다.목차는 다음과 같습니다. 1. 최장 증가 수열이란?2. 최장 증가 수열의 경로는?3. 이진탐색을 통해 최장 증가 수열 찾기4. 이진탐색을 통해 최장 증가 수열의 경로는? LIS LIS란 Longest Increasing Subsequence 최장 증가 수열이라고 말하며, 이는 어떤 수열이 나열 되어있을때, 그 배열의 순서를 유지하며 크기가 점차 커지는 가장 긴 부분수열의 길이가 몇인지를 구하는 알고리즘이라고 할 수 있습니다. 무슨 말인지 예를 들어서 한번 보도록 하겠습니다. 3, 2, 6, 4, 5, 1위와 같은 수열이 있다고 가정하겠습니다. 이때 최장 증가 수열은 무엇일까요? 왼쪽에서 오른쪽으로 확인해보며 봤을 경우,3, 4, 5 또는 2, 4, 5 가 점차적으로 증가하며 부분 수열인 것을 확인 할 수 있습니다. 그럼 이 부분 수열을 과연 어떻게 구할 수 있을까요? 한번 코드로 확인해보도록 하겠습니다. 12345678910111213141516171819202122232425262728import java.util.Arrays;public class LIS_DP &#123; public static void main(String[] args) &#123; int[] list = &#123;3, 2, 6, 4, 5, 1&#125;; int[] LIS = new int[list.length]; // i 번째 숫자를 마지막 숫자로 사용할 경우 최장 증가 수열의 길이를 저장할 배열 for (int i = 0; i &lt; LIS.length; i++) &#123; LIS[i] = 1; for (int j = 0; j &lt; i; j++) &#123; if (list[j] &lt; list[i] &amp;&amp; LIS[i] &lt; LIS[j] + 1)&#123; LIS[i] = LIS[j] + 1; &#125; &#125; &#125; System.out.println(Arrays.toString(LIS)); // 최대 값을 찾기 int maxLISIndex = 0; for (int i = 0; i &lt; LIS.length; i++) &#123; if(LIS[maxLISIndex] &lt; LIS[i])&#123; maxLISIndex = i; &#125; &#125; System.out.println(\"최장 증가 수열의 길이 : \" + LIS[maxLISIndex]); &#125;&#125; 핵심코드는 이 부분 입니다.12345678910for (int i = 0; i &lt; LIS.length; i++) &#123; LIS[i] = 1; // 모든 배열을 값을 1로 초기화 for (int j = 0; j &lt; i; j++) &#123; // 내 앞의 숫자 중에 작은 숫자들을 찾기 if (list[j] &lt; list[i] &amp;&amp; LIS[i] &lt; LIS[j] + 1)&#123; // 나를 기준으로 내앞의 원소가 작으며, // 내가 들고있는 최장 증가 수열의 길이보다 그 값(+1)을 넣은 값이 크다면 LIS[i] = LIS[j] + 1; &#125; &#125;&#125; 이 코드를 해석하자면 다음과 같이 나타 낼 수 있습니다. 주어진 수열{ 3, 2, 6, 4, 5 ,1 } LIS(1) LIS(2) LIS(3) LIS(4) LIS(5) LIS(6) 1 1 2 2 3 1 {3} {2} {3, 6} {3, 4} {3, 4, 5} {1} {3} {2} {2, 6} {2, 4} {2, 4, 5} {1} 따라서 최장 증가 수열의 제일 긴 길이는 LIS(5)의 3이라고 볼 수 있습니다. 경로 구하기 그렇다면 그 최장 증가 수열에서의 경로는 어떻게 구할까요? 코드를 한번 보도록 하겠습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Arrays;public class LIS_DP_Path &#123; public static void main(String[] args) &#123; int[] list = &#123;3, 2, 6, 4, 5, 1&#125;; int[] LIS = new int[list.length]; // i 번째 숫자를 마지막 숫자로 사용할 경우 최장 증가 수열의 길이를 저장할 배열 int[] path = new int[list.length]; // 경로를 역추적 할 배열 for (int i = 0; i &lt; LIS.length; i++) &#123; LIS[i] = 1; // 모든 배열을 값을 1로 초기화 path[i] = -1; // 내 앞의 수열 숫자의 index for (int j = 0; j &lt; i; j++) &#123; // 내 앞의 숫자 중에 작은 숫자들을 찾기 if (list[j] &lt; list[i] &amp;&amp; LIS[i] &lt; LIS[j] + 1) &#123; // 나를 기준으로 내앞의 원소가 작으며, // 내가 들고있는 최장 증가 수열의 길이보다 그 값(+1)을 넣은 값이 크다면 LIS[i] = LIS[j] + 1; path[i] = j; // 내 앞 수열을 찾았기 때문에 그 index 저장 &#125; &#125; &#125; System.out.println(\"LIS : \" + Arrays.toString(LIS)); // 최대 값을 찾기 int maxLISIndex = 0; for (int i = 0; i &lt; LIS.length; i++) &#123; if (LIS[maxLISIndex] &lt; LIS[i]) &#123; maxLISIndex = i; &#125; &#125; System.out.println(\"최장 증가 수열의 길이 : \" + LIS[maxLISIndex]); System.out.println(\"Path : \" + Arrays.toString(path)); StringBuilder lisPath = new StringBuilder(); for (int i = maxLISIndex; i != -1; i = path[i]) &#123; // 최장 증가 수열의 index번호를 기준으로 앞으로 이동하며 -1을 만날 때 까지 출력 lisPath.insert(0, list[i] + \" \"); // 제일 처음으로 삽입 &#125; System.out.println(lisPath.toString()); &#125;&#125; 이 코드의 기본 원리는 내 앞의 수열 Index를 저장하며 마지막에 역추적한다.에 의미를 두고 있습니다. 12345678910for (int i = 0; i &lt; LIS.length; i++) &#123; ... path[i] = -1; // 내 앞의 수열 숫자의 index for (int j = 0; j &lt; i; j++) &#123; // 내 앞의 숫자 중에 작은 숫자들을 찾기 if (list[j] &lt; list[i] &amp;&amp; LIS[i] &lt; LIS[j] + 1) &#123; ... path[i] = j; // 내 앞 수열을 찾았기 때문에 그 index 저장 &#125; &#125;&#125; 내 앞의 숫자를 탐색하며 작은 숫자를 찾을 때 조금의 코드를 추가해주면서 작성할 수 있습니다.path[i] = j;를 작성해주며 경로를 작성 할 수 있으며,결과값을 보도록 하겠습니다. 1234LIS : [1, 1, 2, 2, 3, 1]최장 증가 수열의 길이 : 3Path : [-1, -1, 0, 0, 3, -1]3 4 5 3, 4, 5가 나왔지만, 2, 4, 5 도 됩니다. 프로그램 상 앞으로 현재값을 기준으로 찾기 때문입니다. 좋습니다. 이렇게 최장 증가 수열에 대해서 알아봤지만, 이 알고리즘의 경우 O(n^2)의 시간 복잡도를 갖고 있습니다. i를 n번 돌리며 j가 0부터 i까지 확인 하기 때문에. 좀 더 씬빡 한방법을 생각해보도록 하겠습니다. Binary Search를 통해 LIS 찾기Binary Search로 LIS를 어떻게 찾는지 예시를 통해 확인해보도록 하겠습니다. 8, 2, 4, 3, 6, 11, 7, 10, 14, 5 라는 수열이 있다고 가정해 보겠습니다. LIS List는 LIS로 사용가능한 숫자를 저장하는 List라고 하겠으며,LIS[i]는 가장 작은 값을 LIS[i]에 저장한다고 하겠습니다. 8 2 4 3 6 11 7 10 14 5 8 2 2 2 2 2 2 2 2 2 4 3 3 3 3 3 3 3 6 6 6 6 6 5 11 7 7 7 7 10 10 10 14 14 진행 순서는 다음과 같습니다. 123456789101 : 8을 LIS에 넣음2 : 2를 LIS 이진 탐색을 통해 넣을 위치를 확인(2보다 작은 값 찾지 못함) -&gt; -1을 리턴하며 0번째에 입력3 : 4를 LIS 이진 탐색을 통해 넣을 위치를 확인(4보다 작은 값 2 위치를 -부호로) -&gt; -2를 리턴하며 1번째에 입력4 : 3를 LIS 이진 탐색을 통해 넣을 위치를 확인(3보다 작은 값 2 위치를 -부호로) -&gt; -2를 리턴하며 1번째에 입력4 : 6를 LIS 이진 탐색을 통해 넣을 위치를 확인(6보다 작은 값 3 위치를 -부호로) -&gt; -3를 리턴하며 2번째에 입력5 : 11를 LIS 이진 탐색을 통해 넣을 위치를 확인(11보다 작은 값 6 위치를 -부호로) -&gt; -4를 리턴하며 3번째에 입력6 : 7를 LIS 이진 탐색을 통해 넣을 위치를 확인(7보다 작은 값 6 위치를 -부호로) -&gt; -4를 리턴하며 3번째에 입력7 : 10를 LIS 이진 탐색을 통해 넣을 위치를 확인(10보다 작은 값 7 위치를 -부호로) -&gt; -5를 리턴하며 4번째에 입력8 : 14를 LIS 이진 탐색을 통해 넣을 위치를 확인(14보다 작은 값 10 위치를 -부호로) -&gt; -6를 리턴하며 5번째에 입력9 : 5를 LIS 이진 탐색을 통해 넣을 위치를 확인(5보다 작은 값 3 위치를 -부호로) -&gt; -3를 리턴하며 2번째에 입력 이렇게 최장 증가 수열을 구할 수 있게 됩니다. 그럼 코드로 한번 작성해 보도록 하겠습니다. 12345678910111213141516171819202122import java.util.Arrays;public class LIS_Binary &#123; public static void main(String[] args) &#123; int[] list = &#123;8, 2, 4, 3, 6, 11, 7, 10, 14, 5&#125;; int[] LIS = new int[list.length]; // LIS로 사용가능한 숫자를 저장 int size = 0; // LIS의 개수를 관리할 변수 LIS[size++] = list[0]; // 첫번째 숫자는 바로 반영 for (int i = 1; i &lt; list.length; i++) &#123; if(LIS[size-1] &lt; list[i])&#123; LIS[size++] = list[i]; // 제일 뒤에 붙이기 &#125;else&#123; int temp = Arrays.binarySearch(LIS,0, size, list[i]); // 삽입할 위치 if(temp &lt; 0) temp = -temp -1; LIS[temp] = list[i]; &#125; &#125; System.out.println(\"LIS : \" + Arrays.toString(LIS)); System.out.println(\"LIS의 개수 : \" + size); &#125;&#125; 이 코드에서 가장 중요한 부분은 이 부분 입니다. 123if(LIS[size-1] &lt; list[i])&#123; LIS[size++] = list[i]; // 제일 뒤에 붙이기&#125; 제일 뒤의 원소를 확인 했을 때, 넣을 원소보다 작은 경우에는 LIS 제일 뒤에 붙여넣습니다. 12345else&#123; int temp = Arrays.binarySearch(LIS,0, size, list[i]); // 삽입할 위치 if(temp &lt; 0) temp = -temp -1; LIS[temp] = list[i];&#125; 그렇지 않을 경우 넣을 원소를 LIS 리스트에서 찾아 확인 후 -인덱스를 주며 넣을 위치에다 바꿔치기를 합니다. 결과를 보면 아래와 같습니다. 12LIS : [2, 3, 5, 7, 10, 14, 0, 0, 0, 0]LIS의 개수 : 6 경로 구하기 이진탐색 먼저 코드로 확인해보도록 하겠습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Arrays;public class LIS_Binary_Path &#123; public static void main(String[] args) &#123; int[] list = &#123;8, 2, 4, 3, 6, 11, 7, 10, 14, 5&#125;; int[] LIS = new int[list.length]; // LIS로 사용가능한 숫자를 저장, index 저장 int[] path = new int[list.length]; // 경로를 역추적하기 위해 int size = 0; // LIS의 개수를 관리할 변수 path[size] = -1; // 첫번째 들어갈 수 이므로 -1을 저장 LIS[size++] = 0; // 첫번째 숫자의 index를 반영 for (int i = 1; i &lt; list.length; i++) &#123; // LIS 배열의 마지막 숫자와 수열값을 비교 if (list[LIS[size - 1]] &lt; list[i]) &#123; path[i] = LIS[size - 1]; // 해당 위치를 path[i]에 넣음 LIS[size++] = i; // 제일 뒤에 index 를 붙임 &#125; else &#123; int temp = binarySearch(list, LIS, 0, size, list[i]); // 넣을 위치를 확인 if (temp &lt; 0) temp = -temp - 1; path[i] = path[LIS[temp]]; // 덮어쓸 위치의 index를 내것으로 복사 LIS[temp] = i; &#125; &#125; System.out.println(\"LIS의 개수 : \" + size); StringBuilder lisPath = new StringBuilder(); for (int i = LIS[size - 1]; i != -1; i = path[i]) &#123; lisPath.insert(0, list[i] + \" \"); &#125; System.out.println(\"LIS의 경로 : \" + lisPath.toString()); &#125; private static int binarySearch(int[] a, int[] c, int fromIndex, int toIndex, int key) &#123; int low = fromIndex; int high = toIndex - 1; while (low &lt;= high) &#123; int mid = low + high &gt;&gt;&gt; 1; int midVal = a[c[mid]]; if (midVal &lt; key) &#123; low = mid + 1; &#125; else &#123; if (midVal &lt;= key) &#123; return mid; &#125; high = mid - 1; &#125; &#125; return -(low + 1); &#125;&#125; 위 코드가 좀 복잡해 보일 수 있는데, Binary Search 함수를 따로 구현한 이유는 LIS 리스트는 입력받은 list 배열의 Index를 저장했기 때문입니다. path라는 리스트를 초기 인덱스(-1)부터 값을 LIS에 넣을 때마다 path를 추가해주는 방식을 사용했습니다. 그 경로를 -1이 나올때까지 결과는 다음과 같습니다. 12LIS의 개수 : 6LIS의 경로 : 2 3 6 7 10 14 이렇게 LIS(최장 증가 수열)에 대해서 알아 보았습니다.그럼 관련 알고리즘 문제 링크를 걸어드리며 마무리 짓도록 하겠습니다. 감사합니다.😁 관련 알고리즘 문제&nbsp;&nbsp;가장 긴 증가하는 부분 수열 &nbsp;&nbsp;전깃줄 &nbsp;&nbsp;전깃줄2","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://msnodeve.github.io/categories/algorithm/"},{"name":"skill","slug":"algorithm/skill","permalink":"https://msnodeve.github.io/categories/algorithm/skill/"},{"name":"lis","slug":"algorithm/skill/lis","permalink":"https://msnodeve.github.io/categories/algorithm/skill/lis/"},{"name":"dp","slug":"algorithm/skill/lis/dp","permalink":"https://msnodeve.github.io/categories/algorithm/skill/lis/dp/"},{"name":"binary search","slug":"algorithm/skill/lis/dp/binary-search","permalink":"https://msnodeve.github.io/categories/algorithm/skill/lis/dp/binary-search/"}],"tags":[{"name":"Algorithm","slug":"algorithm","permalink":"https://msnodeve.github.io/tags/algorithm/"},{"name":"LIS","slug":"lis","permalink":"https://msnodeve.github.io/tags/lis/"},{"name":"DP","slug":"dp","permalink":"https://msnodeve.github.io/tags/dp/"},{"name":"Binary Search","slug":"binary-search","permalink":"https://msnodeve.github.io/tags/binary-search/"}]},{"title":"SubSet(부분집합) - [Algorithm Skill]","slug":"algorithm-subset","date":"2020-05-23T09:43:26.000Z","updated":"2020-05-23T10:40:47.067Z","comments":true,"path":"2020/05/23/algorithm-subset/","link":"","permalink":"https://msnodeve.github.io/2020/05/23/algorithm-subset/","excerpt":"알고리즘의 기본적인 스킬을 다룹니다.이번 포스트에서는 알고리즘의 스킬 중 부분집합(Subset)에 대해서 알아 보려고 합니다. Subset BitMask","text":"알고리즘의 기본적인 스킬을 다룹니다.이번 포스트에서는 알고리즘의 스킬 중 부분집합(Subset)에 대해서 알아 보려고 합니다.목차는 다음과 같습니다. 1. 배열체크로 부분집합 구하기2. 비트마스크로 부분집합 구하기3. 관련 알고리즘 문제 Subset 배열체크부분집합이라는 단어는 고등학생때 많이 들어봤던 것 같습니다.일단 부분집합에 대해서 간단하게 알아 보도록 하죠.원소의 개수가 N일때, 부분집합의 개수는 2^N 입니다. 어떻게 그럴까요?1234567891011121314151617181920원소의 개수가 &#123;1, 2&#125; 라고할 때, 다음과 같이 부분 집합이 나올 수 있습니다.∅121, 2총 개수 : 4개원소의 개수가 &#123;1, 2, 3&#125; 라고할 때, 다음과 같이 부분 집합이 나올 수 있습니다.∅1231, 21, 32, 31, 2, 3총 개수 : 8개 그렇다면 이제 코드로 한번 작성해서 확인해 보도록 하겠습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class Subset_Visit &#123; static int N, totalCnt; // 원소의 개수, 총 경우의 수 static int[] inputs; static boolean[] visit; public static void main(String[] args) &#123; // 부분 집합을 구하기 위해서 원소 입력 Scanner sc = new Scanner(System.in); N = sc.nextInt(); inputs = new int[N]; visit = new boolean[N]; for (int i = 0; i &lt; N; i++) &#123; inputs[i] = sc.nextInt(); &#125; // 부분집합 시작 getSubset(0); // 출력 System.out.println(\"총 경우의 수 : \" + totalCnt); &#125; private static void getSubset(int cnt) &#123; // cnt가 원소의 개수만큼 돌았다면 if(cnt == N)&#123; totalCnt++; for (int i = 0; i &lt; N; i++) &#123; // 선택된 배열과 선택되지 않은 배열 출력 System.out.print((visit[i] ? inputs[i] : \"X\") + \"\\t\"); &#125; System.out.println(); return; &#125; // 현재 원소를 선택하고 다음 visit[cnt] = true; getSubset(cnt+1); // 현재 원소를 선택하지 않고 다음 visit[cnt] = false; getSubset(cnt+1); &#125;&#125; 위 코드를 실행해보면 아래와 같은 결과를 얻을 수 있습니다. 1234567891011121314151617181941 2 3 41 2 3 4 1 2 3 X 1 2 X 4 1 2 X X 1 X 3 4 1 X 3 X 1 X X 4 1 X X X X 2 3 4 X 2 3 X X 2 X 4 X 2 X X X X 3 4 X X 3 X X X X 4 X X X X 총 경우의 수 : 16 Subset 비트마스킹위에서 봤던 방문배열을 사용하게 되면 원소의 개수가 커졌을 때, 메모리 사용량이 많이 들어갈 수 있습니다.이번에는 비트마스킹을 이용해서 부분집합을 구해 보도록 하겠습니다. 1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class Subset_Bitmask &#123; static int N; // 원소의 개수 static int[] inputs; public static void main(String[] args) &#123; // 부분 집합을 구하기 위해서 원소 입력 Scanner sc = new Scanner(System.in); N = sc.nextInt(); inputs = new int[N]; for (int i = 0; i &lt; N; i++) &#123; inputs[i] = sc.nextInt(); &#125; // 부분집합 시작 getSubset(1 &lt;&lt; N); // 출력 System.out.println(\"총 경우의 수 : \" + (1 &lt;&lt; N)); &#125; private static void getSubset(int cnt) &#123; for (int flag = 0; flag &lt; cnt; flag++) &#123; // 0, 1, 2 ... flag 비트열 별로 원소 수만큼 각 자리 비트를 확인 for (int i = 0; i &lt; N; i++) &#123; System.out.print((((flag &amp; (1 &lt;&lt; i)) != 0) ? inputs[i] : \"X\") + \"\\t\"); &#125; System.out.println(); &#125; &#125;&#125; 위 코드의 실행 원리를 예시를 들며 설명 하겠습니다. 2개의 원소가 있다고 가정하면 총 경우의 수는 4.8을 Binary로 표현하면 1 0 0 이며, 4번을 돌며 각자리 입력 받은 원소의 개수만큼 비트 이동을 합니다. 1234567891011121314151617181920212223242526flag -&gt; 0 &#x3D; 0 0 일때i -&gt; 0 &#x3D; (1 &lt;&lt; 0) &#x3D; 01, flag &amp; i &#x3D;&gt; 0i -&gt; 1 &#x3D; (1 &lt;&lt; 1) &#x3D; 10, flag &amp; i &#x3D;&gt; 0따라서 X, X 로 표현 됩니다.flag -&gt; 1 &#x3D; 0 1 일때i -&gt; 0 &#x3D; (1 &lt;&lt; 0) &#x3D; 01, flag &amp; i &#x3D;&gt; 1i -&gt; 1 &#x3D; (1 &lt;&lt; 1) &#x3D; 10, flag &amp; i &#x3D;&gt; 0따라서 1, X 로 표현 됩니다.flag -&gt; 2 &#x3D; 1 0 일때i -&gt; 0 &#x3D; (1 &lt;&lt; 0) &#x3D; 01, flag &amp; i &#x3D;&gt; 0i -&gt; 1 &#x3D; (1 &lt;&lt; 1) &#x3D; 10, flag &amp; i &#x3D;&gt; 1따라서 X, 1 로 표현 됩니다.flag -&gt; 3 &#x3D; 1 1 일때i -&gt; 0 &#x3D; (1 &lt;&lt; 0) &#x3D; 01, flag &amp; i &#x3D;&gt; 1i -&gt; 1 &#x3D; (1 &lt;&lt; 1) &#x3D; 10, flag &amp; i &#x3D;&gt; 1따라서 1, 2 로 표현 됩니다. 위 코드를 실행해보면 아래처럼 결과가 나오는 것을 확인 할 수 있습니다. 123456721 2X X 1 X X 2 1 2 총 경우의 수 : 4 이렇게 부분집합에 대해서 알아 보았습니다.그럼 관련 알고리즘 문제 링크를 걸어드리며 마무리 짓도록 하겠습니다. 감사합니다.😁 관련 알고리즘 문제&nbsp;&nbsp;부분수열의 합","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://msnodeve.github.io/categories/algorithm/"},{"name":"skill","slug":"algorithm/skill","permalink":"https://msnodeve.github.io/categories/algorithm/skill/"},{"name":"subset","slug":"algorithm/skill/subset","permalink":"https://msnodeve.github.io/categories/algorithm/skill/subset/"},{"name":"bitmask","slug":"algorithm/skill/subset/bitmask","permalink":"https://msnodeve.github.io/categories/algorithm/skill/subset/bitmask/"}],"tags":[{"name":"Algorithm","slug":"algorithm","permalink":"https://msnodeve.github.io/tags/algorithm/"},{"name":"Subset","slug":"subset","permalink":"https://msnodeve.github.io/tags/subset/"},{"name":"Bit","slug":"bit","permalink":"https://msnodeve.github.io/tags/bit/"},{"name":"BitMask","slug":"bitmask","permalink":"https://msnodeve.github.io/tags/bitmask/"}]},{"title":"Recursive(재귀) - [Algorithm Skill]","slug":"algorithm-recursive","date":"2020-03-17T01:38:59.000Z","updated":"2020-05-05T05:23:05.208Z","comments":true,"path":"2020/03/17/algorithm-recursive/","link":"","permalink":"https://msnodeve.github.io/2020/03/17/algorithm-recursive/","excerpt":"알고리즘의 기본적인 스킬을 다룹니다.이번 포스트에서는 알고리즘의 스킬 중 재귀에 대해서 알아 보려고 합니다. Factorial Fibonacci Fibonacci Memoization Hanoi","text":"알고리즘의 기본적인 스킬을 다룹니다.이번 포스트에서는 알고리즘의 스킬 중 재귀에 대해서 알아 보려고 합니다.목차는 다음과 같습니다. 1. Factorial2. Fibonacci3. Fibonacci Memoization4. 관련 알고리즘 문제 Factorial 팩토리얼이라는 단어 많이 들어 보셨을 거라 생각합니다. 간단하게 다음과 같이 식을 세울 수 있습니다. n! = n * (n - 1)! 즉 예시를 들어 보면 다음과 같겠죠. 123450! &#x3D; 11! &#x3D; 1 * (1 - 1)! &#x3D; 1 * 0! &#x3D; 12! &#x3D; 2 * (2 - 1)! &#x3D; 2 * 1! &#x3D; 2...5! &#x3D; 5 * (5 - 1)! &#x3D; 5 * 4! &#x3D; 120 이렇게 n!을 코드로 한번 작성해 보고자 합니다. 아마 대표적인 재귀함수의 기본이지 않을까 싶습니다. 그럼 이제 코드를 한번 살펴 보도록 하겠습니다. 123456789101112131415161718192021222324import java.io.BufferedReader;import java.io.InputStreamReader;public class Factorial &#123; public static void main(String[] args) throws Exception &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); System.out.println(factorial(N)); &#125; // n! : n * (n-1)! // n! 계산 private static long factorial(int n) &#123; // 기저(재귀 탈출) if (n == 1) return 1; // 유도(파생) return n * factorial(n - 1); &#125;&#125; 이 코드에서 중요한 점은 재귀를 선언하면 무한 반복을 돌지않게 하기 위해 `기저 조건` 과 `다시 호출`을 하는 것이 가장 중요합니다. 재귀로 하고자 한다면 다음과 같이 선언을 한 뒤 사용하는 것이 좋을 것 같습니다. ~(개인적인 견해 입니다.)~ 1234567private static long factorial(int n)&#123; // 기저 조건 // 목표값에 도달했을 경우 빠져나가야 하기 때문입니다. // 파생 조건 // 목표값에 도달했지 않았을 경우 계속 돌아야 하기 때문입니다.&#125; 코드는 직접 한번 작성해보시기 바랍니다 😌 ## Fibonacci 피보나치 수열? 이 또한 많이 들어 보셨을 것 같습니다. 0번째 항을 0, 1번째 항을 1로 두고, 2번째 항부터는 바로 앞의 두 수를 더한 수가 됩니다. 16 번째 항까지만 나열해 보자면, 10, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987 규칙은 정말 간단하죠? 그럼 다음과 같이 식을 세울 수 있겠군요. f(n) = f(n - 1) + f(n - 2) 이제 우리가 해야할 일은 f(n) 의 값은 과연 몇일까?🤔 를 구하는 것 입니다.그럼 코드로 한번 구현을 해보도록 하겠습니다! 일단 위에서 말했지만, 재귀를 사용하기 위해서는 먼저 틀을 만들어야 합니다. 그리고 코드를 한번 볼까요? 123456789101112131415161718192021import java.io.BufferedReader;import java.io.InputStreamReader;public class Fibonacci &#123; public static void main(String[] args) throws Exception &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); System.out.println(fibonacci(N)); &#125; private static long fibonacci(int n) &#123; // 1. 우선 재귀를 그만둘 수 있는 기저 조건 // n이 0, 1일때 결과값은 0과 1이기 때문에 return n을 주었습니다. if (n &lt;= 1) &#123; return n; &#125; // 그렇다면 계속 파생조건을 주어야 겠죠. return fibonacci(n - 1) + fibonacci(n - 2); &#125;&#125; 계산이 어떻게 이루지는지 한번 보도록하겠습니다. 1234567891011N에 4를 입력했을 경우,1. fibonacci(4) 함수 호출2. n &lt;&#x3D; 1 아니기 때문에 return fibonacci(4 - 1) + fibonacci(4 - 2) 중에 첫번째 fibbonacci(4 - 1) 함수 호출3. n &lt;&#x3D; 1 아니기 때문에 return fibonacci(3 - 1) + fibonacci(3 - 2) 중에 첫번째 fibbonacci(3 - 1) 함수 호출4. n &lt;&#x3D; 1 아니기 때문에 return fibonacci(2 - 1) + fibonacci(2 - 2) 중에 첫번째 fibbonacci(2 - 1) 함수 호출5. n &lt;&#x3D; 1 이기때문에 return 1; 반환 후 4. 단계에서 두번째 fibonacci(2 - 2) 함수 호출 (현재 결과 값 1)6. n &lt;&#x3D; 1 이기때문에 return 0; 반환 후 3. 단계에서 두번째 fibonacci(3 - 2) 함수 호출 (현재 결과 값 1)7. n &lt;&#x3D; 1 이기때문에 return 1; 반환 후 2. 단계에서 두번째 fibonacci(4 - 2) 함수 호출 (현재 결과 값 2)8. n &lt;&#x3D; 1 아니기 때문에 return fibonacci(2 - 1) + fibonacci(2 - 2) 중에 첫번째 fibbonacci(2 - 1) 함수 호출9. n &lt;&#x3D; 1 이기때문에 return 1; 반환 후 8. 단계에서 두번째 fibonacci(2 - 2) 함수 호출 (현재 결과 값 3)10. n &lt;&#x3D; 1 이기때문에 return 0; 반환 후 최종 결과 값 3 반환 이해가 가지 않을 수 있습니다. 눈으로 보는 것 보다, 그리고 머리로 생각하는 것 보다 손으로 한번 써보는게 더 기억에 잘 남는다고 하니 한번 손으로 작성해보는 것도 좋은 방법인듯 합니다. 자! 여기서 잠깐… 혹시 N의 입력 값에 42이상의 값을 입력 해보셨나요? 결과 값이 조금 늦게 나오지 않았나요?음 늦게 나오지않았다면 정말 좋은 컴퓨터를 사용중이시네요 그럼 100을 입력해보시죠 하루를 걸려서라도 결과값은 나오지 않을거에요… 이거 왜이러는 걸까요? 그림을 한번 볼까요? 함수안에서 같은 함수를 호출(재귀)하게되면 콜스택에 쌓이게 됩니다. 그렇다면 위 그림을 비교해서 보자면 fibonacci(5) 즉, 5번째는 어떤 피보나치 수가 될지 확인해보기 위해서는 fibonacci(0)을 3번, fibonacci(1)을 5번, fibonacci(2)을 3번 … 이렇게 앞에 구했던 함수를 계속해서 함수 호출을 통해 5번째 피보나치 수를 구할 수 있게 됩니다. 그렇다면 이미 구했다면 더 이상 구하지 않게 하기 위해서는 어떤 방법이 필요할까요? 바로 Memoization! 을 이용하면 되겠습니다. Fibonacci Memoization우선 바로 코드를 보도록 하겠습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;public class FibonnaciMemoization &#123; static long[] call1, call2, memo; static long totalCnt1, totalCnt2; private static long fibo(int n) &#123; // 메모를 하지 않은 경우 call1[n]++; totalCnt1++; if (n &lt;= 1) return n; return fibo(n - 1) + fibo(n - 2); &#125; private static long fibo2(int n) &#123; // 메모를 한 경우 call2[n]++; totalCnt2++; if (n &lt;= 1) return n; // n항의 값을 계산한 적이 있었다면(메모 확인) 메모된 값 리턴 if (memo[n] != 0) &#123; return memo[n]; &#125; return memo[n] = fibo2(n - 1) + fibo2(n - 2); &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); call1 = new long[N + 1]; call2 = new long[N + 1]; memo = new long[N + 1]; System.out.println(fibo2(N)); for (int i = 1; i &lt;= N; i++) &#123; System.out.println(\"fibo2(\" + i + \") : \" + call2[i]); &#125; System.out.println(\"fibo2 call count : \" + totalCnt2); System.out.println(\"============================\"); System.out.println(fibo(N)); for (int i = 1; i &lt;= N; i++) &#123; System.out.println(\"fibo(\" + i + \") : \" + call1[i]); &#125; System.out.println(\"fibo call count : \" + totalCnt1); System.out.println(\"============================\"); &#125;&#125; 이제 5 를 입력하고 돌려보시면 다음과 같은 결과를 보실 수 있습니다. 123456789101112131415161755fibo2(1) : 2fibo2(2) : 2fibo2(3) : 2fibo2(4) : 1fibo2(5) : 1fibo2 call count : 9&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;5fibo(1) : 5fibo(2) : 3fibo(3) : 2fibo(4) : 1fibo(5) : 1fibo call count : 15&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 같은 함수를 호출(재귀) 하면서 이전에 이미 구해놓았던 memo[-] 결과 값이 있다면 바로 리턴을 해주며 값을 계속 구하고 있는 모습을 보실 수 있습니다. 이렇게 돌려본 결과단순히 재귀를 돌렸을 경우 총 카운트는 15번메모이제이션을 한 뒤 돌렸을 경우 총 카운트는 9번으로 함수 콜스택을 줄여준 결과를 보여주고 있습니다. 이렇게 재귀함수에 대해서 알아 보았습니다.그럼 관련 알고리즘 문제 링크를 걸어드리며 마무리 짓도록 하겠습니다. 감사합니다.😁 관련 알고리즘 문제&nbsp;&nbsp;피보나치 수 &nbsp;&nbsp;피보나치 수 2","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://msnodeve.github.io/categories/algorithm/"},{"name":"skill","slug":"algorithm/skill","permalink":"https://msnodeve.github.io/categories/algorithm/skill/"},{"name":"recursive","slug":"algorithm/skill/recursive","permalink":"https://msnodeve.github.io/categories/algorithm/skill/recursive/"}],"tags":[{"name":"Algorithm","slug":"algorithm","permalink":"https://msnodeve.github.io/tags/algorithm/"},{"name":"Recursive","slug":"recursive","permalink":"https://msnodeve.github.io/tags/recursive/"},{"name":"Factorial","slug":"factorial","permalink":"https://msnodeve.github.io/tags/factorial/"},{"name":"Hanoi","slug":"hanoi","permalink":"https://msnodeve.github.io/tags/hanoi/"},{"name":"Fibo","slug":"fibo","permalink":"https://msnodeve.github.io/tags/fibo/"}]},{"title":"Hexo[Tranquilpeak] 사용방법","slug":"devlog-hexo-syntax","date":"2020-03-13T11:09:58.000Z","updated":"2020-03-17T08:15:32.830Z","comments":true,"path":"2020/03/13/devlog-hexo-syntax/","link":"","permalink":"https://msnodeve.github.io/2020/03/13/devlog-hexo-syntax/","excerpt":"Hexo[tranquilpeak 테마]이번 포스트에서는 Hexo 테마 중 Tranquilpeak, 어떻게 사용하는지에 대해 알아 보려고 합니다. Tag Alert Highlight Text","text":"이번 포스트에서는 Hexo 테마 중 Tranquilpeak, 어떻게 사용하는지에 대해 알아 보려고 합니다.목차는 다음과 같습니다. 1. Alert를 사용하는 방법!2. Highlight Text를 사용하는 방법! TagAlert Alert을 사용하는 방법 Info 알림을 사용하는 방법은 어떻게!? Success 알림을 사용하는 방법은 어떻게!? Warning 알림을 사용하는 방법은 어떻게!? Danger 알림을 사용하는 방법은 어떻게!? 아이콘이 거슬린다구요? 그럼 이렇게 표시는 어떨까요?? Info 알림을 사용하는 방법은 어떻게!? Success 알림을 사용하는 방법은 어떻게!? Warning 알림을 사용하는 방법은 어떻게!? Danger 알림을 사용하는 방법은 어떻게!? 우선 위와 같이 이 테마에서 가능한 md문법에 대해서 알아보도록 하겠습니다! 문법은 다음과 같습니다.123&#123;% alert [classes] %&#125;content&#123;% endalert %&#125; 파라미터 이름 값 info success Classes warning danger no-icon 위에 보시는 [classes]에 값을 넣고 작성하면 됩니다. 또한 표에서 보이는 5번째줄의 값(no-icon)은 icon을 보여주지 않고 Alert을 쓰는 방법입니다. 아래와 같이 쓰시면 됩니다. 123&#123;% alert info no-icon %&#125;Info 알림의 예시 코드&#123;% endalert %&#125; Info 알림 결과 ! Highlight Text Highlight Text을 사용하는 방법 Highlight Text는 형광펜을 그은 처럼 작성하는 것 입니다. 일단 예시를 보도록 하겠습니다. 1. 첫번째 형광펜은 기본 문법으로 2. 두번째 형광펜은 hexa color 문법으로 문법은 다음과 같습니다.123&#123;% hl_text [(classes | hexa code | rgb color | rgba color)] %&#125; content&#123;% endhl_text %&#125; 파라미터 이름 값 red green blue purple orange Classes yellow cyan primary success warning danger 위에 보시는 [(classes | hexa code)]에 값을 넣고 작성하면 됩니다. 또한 hexa code로도 작성할 수 있습니다. 사용 코드 예시는 아래와 같습니다. 123456&lt;p&gt;&lt;!-- basic code --&gt;1. &#123;% hl_text orange %&#125;첫번째 형광펜&#123;% endhl_text %&#125;은 기본 문법으로&lt;br&gt;&lt;!-- hexa code --&gt;2. &#123;% hl_text #00FFFF %&#125;두번째 형광펜&#123;% endhl_text %&#125;은 hexa color 문법으로&lt;/p&gt; 1. 첫번째 형광펜은 기본 문법으로 2. 두번째 형광펜은 hexa color 문법으로","categories":[{"name":"devlog","slug":"devlog","permalink":"https://msnodeve.github.io/categories/devlog/"},{"name":"hexo","slug":"devlog/hexo","permalink":"https://msnodeve.github.io/categories/devlog/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://msnodeve.github.io/tags/hexo/"},{"name":"Syntax","slug":"syntax","permalink":"https://msnodeve.github.io/tags/syntax/"}]},{"title":"SSAFY 3기를 시작하며![합격 후기]","slug":"story-ssafy-3rd","date":"2019-12-24T12:04:36.000Z","updated":"2020-05-23T10:49:12.929Z","comments":true,"path":"2019/12/24/story-ssafy-3rd/","link":"","permalink":"https://msnodeve.github.io/2019/12/24/story-ssafy-3rd/","excerpt":"SSAFYSamsung Software Academy For Youth(삼성 청년 소프트웨어 아카데미) 서울 지역에 합격했습니다! 😘 그런 의미로 이야기를 한 번 써내려 가려 합니다.","text":"SSAFYSamsung Software Academy For Youth(삼성 청년 소프트웨어 아카데미) 서울 지역에 합격했습니다! 😘 그런 의미로 이야기를 한 번 써내려 가려 합니다. 2018년 1월부터 1기, 1,000명 선발을 시작으로 2022년까지 총 10,000명을 선발한다고 했습니다! (저는 사실 SSAFY를 3기 모집 1달 전에 알게 되었어요…) 이렇게 보니 규모가 정말 상당하다라고 생각이 듭니다. 또한 이 아카데미를 듣는 동안 달마다 삼성전자의 이름으로 100만원의 지원금(취업을 한 것이 아니라서, 취직 지원금 까지 신청이 가능하다고 합니다!)을 받을 수 있다고 하니 정말 대단해요!(역시 갓성전자…) 매년 두 기수 씩 교육생을 선발하는 중이며, 저는 2020년 2월 졸업 예정자로써 3기로 지원했으며 합격해서 교육을 듣게 되었습니다! 그럼 이제 SSAFY 3기 모집은 언제 였으며, 어떻게 준비를 했는지 이야기를 하겠습니다. 😊😊 이 포스트는 다음과 같은 흐름으로 정리해 보았습니다. 1. SSAFY를 어떻게 알게 되었나? 2. SSAFY 교육 과정 3. SSAFY 선발 과정 4. SSAFY.. 어떻게 들어갔는가? 5. SSAFY 결과 발표 SSAFY를 어떻게 알게 되었나주변 사람들로 인해 알게 되었어요. 제가 SSAFY를 알기전에 삼성 청년 SW 아카데미 모집 설명회가 있었다고 하던데… 미리 알았다면 아마 가보지 않았을까.. 눈물이 나네요😭😭 SSAFY 모집 설명회 일정 및 장소 이미지의 출처는 SSAFY(ssafy.com)에서 가져왔음을 밝힙니다. 위와 같이 10월 28일 부터 시작해 10월 31일 까지 4일에 걸쳐 진행되었다고 합니다! 장소 관계 신청으로 인해 조기 마감이 될 수 있다고 하더라구요…(참여하면 소정의 기념품 까지 챙겨줬는데😭😭) 참여한 것이 아니라 정확한 내용을 알려 드리기에는 한계가 있어 링크를 남겨 드립니다! SSAFY 3기 모집 설명회 : https://webstudynote.tistory.com/23 이전에 SSAFY 올레 행사도 있었다고 하네요! SSAFY 올레 행사 후기 : https://webstudynote.tistory.com/19 SSAFY 교육 과정 교육 장소 : 전국 4개 지역(서울, 대전, 광주, 구미) 교육 기간 : 2020년 1월 6일(월) ~ 2020년 12월 31일(목) (12개월) 12개월 기간동안의 세부 과정은 아래 사진과 같습니다. 이미지의 출처는 SSAFY(ssafy.com)에서 가져왔음을 밝힙니다. 기본과정(5개월) : 기본적으로 컴퓨터와 관련된 지식을 습득하기 위한 기간이라고 보시면 될것 같습니다! 이 과정에서는 Computational Thinking, Algorithm, Computer language(Python, Java, C++…등등) 을 배울 예정이라고 하네요! 1차 Job Fair(1개월) : 5개월동안 과정을 진행하면서 성적 우수자 대상으로 해외 연수도 보내주며, 필요한 사람에 한해 보충수업도 제공된다고 하네요. 심화과정(5개월) : 제일 중요한 시점인 것 같습니다. 기본 과정을 진행하면서 습득한 기본 지식을 통해 팀을 꾸려 하나의 프로젝트를 만들어 내는 과정이며, 프로젝트를 진행하기에 앞서 멘토들도 계신다고 하니 정말 좋은 시간이 될 것 같아요! 2차 Job Fair(1개월) : SSAFY의 마지막 1개월 활동.. SSAFY에서 개인별 맞춤형 경력 설계를 도와주며, 그에 맞게 취업 활동 및 채용 정보도 잘 알려 준다고 합니다! 이 과정까지 수료하게 된다면 뿌듯하고, 즐거울 것 같습니다(한편으로는 슬플 수도 있을 거 같군요😭) SSAFY에서 총 12개월의 교육 기간을 통해 &quot;문제해결 능력을 갖춘 차세대 SW인력 양성&quot; 을 목표로 정말 실전형 SW 개발자로 거듭날 수 있을 것 같습니다! 😁😁 SSAFY 선발 과정지원 자격 부터 선발 과정까지 자세하게 보도록 하겠습니다! 😉 지원 자격대상 연령 : 만 29세 이하 (1990. 1. 1 이후 출생자) 학력 : 국내외 4년제 대학(학사 이상) 졸업자 및 2020.2월 졸업 예정자(전공 무관) 재직 여부 현재 미 취업자 대상 인터뷰일(2019.12.3)부터 본 교육 시작일(2020.1.6) 전까지 재직(예정)자 지원불가(사업장 건강보험 및 국민연금 가입 여부기준) ※ 교육기간 중 취업할 경우, 해당 업체 입사전에 개별적으로 퇴소 기타사항 교육시작일 교육 입과 가능한 자 교육기간 중 통학 가능한 자(별도 숙소 제공 없음) 병역필 또는 면제자로 해외여행에 결격 사유가 없는 자 이미지의 출처는 SSAFY(ssafy.com)에서 가져왔음을 밝힙니다. 위와 같이 4단계에 걸쳐 선발을 합니다! 이제 자세하게 알려 드리도록 하겠습니다 😁 SSAFY 어떻게 들어갔는가지금부터는 위에서 봤던 4단계를 어떻게 진행했는지, 어떤 생각으로 면접을 봤는지, 알려드릴 수 있는 범위에서 자세하게 알려 드리도록 하겠습니다. 지원서를 접수하기 위해서는 SSAFY 홈페이지를 접속해 회원가입 및 로그인 후 온라인으로 지원서를 작성 할 수 있어요. (회원 인증 메일 확인 사진을 올리고 싶었으나, 제 3자에게 공개 또는 배포, 복사하는 것을 엄격히 금지하고 있어 올리지 못했습니다) Step 1) 지원서 접수(2019.10.28 ~ 11.11)지원서 접수는 SSAFY 홈페이지에서 지원 가능했습니다. 지원서에는 다음과 같은 항목을 작성해야 했어요. 기본 인적 사항 : 이름, 생년월일, 성별, 휴대폰 번호, 비상 연락처, 이메일, 주소 기재 학력 사항 : 최종 학력, 입학 일 및 졸업 일, 전공, 만점 기준 취득 학점 기재 경력 및 어학 사항 : 경력(인턴 및 근무 경험), 병역 사항, 어학(외국어 자격증 등) 어학 자격증은 1도 없었어요. 😭그렇지만 해본 경험은 죄다 적었습니다. 😎 희망지역 및 진단일정 : 1지망, 2지망(서울, 대전, 광주, 구미 중 택 2), SW적성 검사 진단 일정 선택 희망지역 - 1지망(서울 : 멀티캠퍼스 교육센터), 2지망(대전 : 삼성화재 유성연수원)진단일전 - 11월 16일 토요일 10시, 12시 이렇게 2개가 있었어요. SW관련 활동 : 학교에서 배운 전공 학점 및 공통 학점 기재, 교육이수 / 개발경험 / 수상경력 기재 저는 전공자여서 그런지 학점을 기재하고 보니 많았어요!(한 페이지를 꽉 채운느낌?)개발 경험과 수상 경력이 좀 있었던 것 같아요! 있는 대로 죄다 작성했습니다. 😎 에세이 : 2가지의 질문이 있었습니다! 두 질문 모두 500자 이상의 글을 작성해야 했습니다. 첫 번째는 SSAFY를 지원하게 된 동기, 향후 진로가 어떻게 될지두 번째는 외부 활동을 하며 겪었던 경험에 대해서 물어 보았습니다. 부가 인적 사항 : 장애인, 기초생활수급자 / 차상위계층 지원서에서 가장 중요한 항목이였던 에세이.질문의 의도를 캐치하면 다음과 같이 생각해 낼 수 있었어요!내가 왜 SSAFY가 필요한지, 커리큘럼을 따라하면 내 미래가 어떻게 변할지에 대한 질문 이였던 것 같아요! Step 2) SW 적성 진단(11.16)SW 적성 진단은 총 60분 동안 진행 되었으며, 2가지의 온라인 테스트로 진행 되었습니다. 첫 번째 수리/추리 논리 능력 진단(30분)으로 말 그대로 수리, 추리, 논리 능력을 진단 하는 내용을 다뤘습니다.두 번째 Computational Thinking 진단(30분)으로 문제를 컴퓨터 적인 생각으로 알고리즘을 생각해 진단 하는 내용을 다뤘습니다.(코딩 테스트가 아닌가 라는 생각으로 겁 먹었지만, 주어진 문제를 계산(알고리즘 풀이) 해 단답형 으로 제출하는 형식이였습니다, 그러나 1문제 맞췄나…😅😅) 문제 유출은 금지 사항이므로 어떤 문제가 나왔는지는 말씀 드리기가 어렵군요! 별도 사항 진단 하는 동안 총 10번의 재 접속 가능 2개의 진단 모두 응시 선택한 시간 외 접속 불가 실제 진단에 필요한 보안 프로그램을 설치 후 응시 운영체제(OS) : Windows 7, Windows 8, Windows 10해상도 : 1280 X 1024 이상 해상도 사용 권장웹 브라우저 : Internet Explorer(10이상), Google Chrome(최신버전)저는 mac 유저지만.. 이 날 만큼은 Windows로 진단을 봤어요! SW 적성 진단을 하면서 느낀점은 “아… 시작부터 불합격이 뜨겠구나” 이였지만 의외로 대부분의 지원자들이 합격 소식을 많이 들었어요! (그렇지만 저는 왜 합격한지 아직도 감사할 나름…!) Step 3) Interview(12.3 ~ 12.5)삼성 청년 SW 아카데미 3기 Interview 대상자로 선정 되었지만, 준비를 어떻게 해야 하는지 몰랐고, SSAFY가 시작한지 1년이 되었지만 정보도 많이 없었던 것 같습니다. 먼저 Interview를 보기 전 온라인 사전 학습을 해야 했었는데요! 이는 안내 메일로 왔습니다. 온라인 사전 학습으로 3가지의 과정 중 1개의 과정을 선택해 학습을 진행하는 방식입니다. IT 트랜드 창의/열정 SW기초 학습 기간 : 2019.11.23(토) 00:00 ~ 11.28(목) 23:59(총 6일) 지정된 학습 일정 이외에는 수강 불가 유의 사항으로는 사전 학습 미 수료의 경우에도 인터뷰는 참석 가능하지만, 선발 절차 중 하나 이므로, 성실히 수강 해야한다고 했습니다. 사전 학습을 통해 관련 분야의 지식을 얻을 수 있는 유익한 시간이 되었습니다. 이제 대망의 SSAFY Interview… 저는 12월 5일 Interview를 진행했습니다. ■ 일시 : 2019. 12. 5(목) 9:15 예상 소요 시간 : 대기시간 포함 2시간 30분저는 한 2시간 정도 걸렸던 것 같습니다! 😁 ■ 장소 서울 삼성 금융 캠퍼스 ■ 내용 Interview 안내 서류 확인 2차 SW 적성진단 (CBT) Interview ■ 복장 Interview에 적합한 단정한 복장 ■ 준비물 필수 서류 [원본] 신분증 (주민등록증/운전면허증/유효기간 만료전 여권에 한함) 4대보험 가입내역 확인서 (가입여부 확인) 졸업(예정)증명서, 성적 증명서 (석사인 경우 학사/석사 모두 지참) 기타 서류 : 대상자에 한함 (지원서에 기재한 자격 증빙) [원본] : 병적(병역) 증명서, 어학성적 증명서, 장애인/기초생활수급 대상 확인서 [사본 가능] : 자격증, 수상내역 확인증, 경력 증명서 等 기타 서류 ※ 서울 外 지역에서 참석하시는 분들께는 소정의 면접비 지급 예정 (지원서에 기재한 주소 기준)(면접비 까지주는 이런…😭😭) 처음 Interview 보는 것 치고는 분위기가 좋았습니다.본인이 SSAFY가 왜 필요한지, 어떤 것을 해보고 싶은지 IT 관련해서 얼마나 관심을 갖고 있는지를 묻는 정말 제게 궁금한 점을 물어보는 인터뷰 시간이였습니다. 😲😲 본 Interview 내용은 보안 서약서를 작성 했기 때문에 Interview 진행 했던 사항은 말씀 드릴 수 없습니다! SSAFY 결과 발표길고도 긴… 기대하고 기대했던 결과 발표의 기다림… 🙏🙏2주 정도 기다린 것 같아요. 문자 메세지로 홈페이지에서 Interview 결과를 확인 하라고 왔습니다.기다리던 순간… 결과 확인을 누르기가 정말 떨렸어요. 😭 이미지의 출처는 SSAFY(ssafy.com)에서 가져왔음을 밝힙니다. Interview 결과 합격이라는 단어를 본 순간 소리 질렀네요(당시 서울에서 부산으로 내려가는 기차 안이였는데 😂)입과, 입과포기 란이있었는데 보자마자 입과 누르고 확인 했습니다. 이미지의 출처는 SSAFY(ssafy.com)에서 가져왔음을 밝힙니다. 그리고 결과 발표 하루 뒤에 문자로 최종 합격 문자가 왔어요.알고있던 결과라도 다시 확인하니 너무 행복했습니다. 😍😍 부족한 부분이 있었는지 모르겠네요!! 이렇게 해서 SSAFY 3기를 합격하게 되었습니다!좀 더 궁금한 사항이 있다면 댓글로 남겨주세요! 썸네일의 출처는 SSAFY(ssafy.com)에서 가져왔음을 밝힙니다.","categories":[{"name":"story","slug":"story","permalink":"https://msnodeve.github.io/categories/story/"},{"name":"ssafy","slug":"story/ssafy","permalink":"https://msnodeve.github.io/categories/story/ssafy/"}],"tags":[{"name":"SSAFY","slug":"ssafy","permalink":"https://msnodeve.github.io/tags/ssafy/"},{"name":"Samsung","slug":"samsung","permalink":"https://msnodeve.github.io/tags/samsung/"},{"name":"Academy","slug":"academy","permalink":"https://msnodeve.github.io/tags/academy/"},{"name":"Software","slug":"software","permalink":"https://msnodeve.github.io/tags/software/"}]},{"title":"Linux, CentOS 작업 스케쥴러 - Crontab","slug":"devlog-linux-crontab","date":"2019-12-09T07:46:52.000Z","updated":"2020-03-17T08:15:44.314Z","comments":true,"path":"2019/12/09/devlog-linux-crontab/","link":"","permalink":"https://msnodeve.github.io/2019/12/09/devlog-linux-crontab/","excerpt":"Crontab?Cron 은 리눅스 에서 특정한 명령이나 스크립트를 지정한 날짜/시간에 자동으로 실행해 주는 스케쥴러 입니다. 주기적으로 시스템 백업 스크립트를 실행하는 등 시스템 관리자에 의해 많이 사용되며, 이외 반복적인 작업을 하기위해 사용될 수 있습니다.","text":"Crontab?Cron 은 리눅스 에서 특정한 명령이나 스크립트를 지정한 날짜/시간에 자동으로 실행해 주는 스케쥴러 입니다. 주기적으로 시스템 백업 스크립트를 실행하는 등 시스템 관리자에 의해 많이 사용되며, 이외 반복적인 작업을 하기위해 사용될 수 있습니다. Crontab 활용 용도 30분 단위로 이메일을 전송 할 때 매주 일요일 새벽 4시에 서버를 재 시작 할 때 위와 같이 반복적인 예약 작업이 필요할 때 다양하게 활용할 수 있는 도구 입니다. Install crontab - CentOSyum 을 통해 Crontab 을 설치합니다. 1$ yum -y install cronie Crontab 설치가 완료 되었다면, Crontab 서비스가 잘 작동 하고 있는지 확인합니다. 1234567$ systemctl start crond$ systemctl list-unit-filesUNIT FILE STATE...crond.service enabled... How to use crontab?Crontab 리스트 조회1$ crontab -l crontab에 등록된 스케쥴러 작업 리스트를 확인합니다. Crontab 편집1$ crontab -e crontab 예약 작업 리스트를 편집 할 수 있는 에디터가 실행 되며, 편집합니다. Crontab 리스트 삭제1$ crontab -r crontab에 등록된 모든 스케쥴러 작업 리스트를 삭제합니다. Crontab 작성 방법123456789* * * * * 수행할 명령어┬ ┬ ┬ ┬ ┬│ │ │ │ ││ │ │ │ ││ │ │ │ └───────── 요일 (0 - 6) (0:일요일, 1:월요일, 2:화요일, …, 6:토요일)│ │ │ └───────── 월 (1 - 12)│ │ └───────── 일 (1 - 31)│ └───────── 시 (0 - 23)└───────── 분 (0 - 59) crontab -e 명령어를 사용해 위와 같은 형식으로 스케쥴러를 등록합니다. Example crontab간단한 텍스트를 파일에 쓰는 것을 해보겠습니다. 1$ crontab -e crontab 편집기를 열고 작업을 등록합니다. 1* * * * * echo \"Hello 두번 개발하는 블로그\" &gt;&gt; ~/test.txt ESC + qw 저장하고 밖으로 빠져 나옵니다. 1분이 지나게 되면 root 경로에 test.txt 파일이 생긴 것을 볼 수 있으며, 파일 내부에는 Hello 두번 개발하는 블로그 라는 텍스트가 작성 되어 있는 것을 볼 수 있습니다. 다른 예제특정 시간에 실행 1 매주 일요일 새벽 4시 20분에 test! 텍스트를 root 경로 밑 test.txt 파일에 작성 120 4 * * 0 echo \"test!\" &gt;&gt; ~/test.txt 특정 시간에 실행 2 매주 화요일 오후 1시 30분, 40분, 50분에 test! 텍스트를 root 경로 밑 test.txt 파일에 작성 110,20,30 13 * * 2 echo \"test!\" &gt;&gt; ~/test.txt Crontab 작성 기호 종류1234* # 범위 내 모두 실행, # 나열된 숫자 중 일치하는 값에 실행- # 두 숫자 사이에 포함된 범위에 실행/ # 지정한 숫자에 실행","categories":[{"name":"devlog","slug":"devlog","permalink":"https://msnodeve.github.io/categories/devlog/"},{"name":"linux","slug":"devlog/linux","permalink":"https://msnodeve.github.io/categories/devlog/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://msnodeve.github.io/tags/linux/"},{"name":"CentOS","slug":"centos","permalink":"https://msnodeve.github.io/tags/centos/"},{"name":"Infra","slug":"infra","permalink":"https://msnodeve.github.io/tags/infra/"},{"name":"Cron","slug":"cron","permalink":"https://msnodeve.github.io/tags/cron/"},{"name":"Crontab","slug":"crontab","permalink":"https://msnodeve.github.io/tags/crontab/"}]},{"title":"Hexo Blog 만들기","slug":"hexo-blog-init","date":"2019-10-31T06:51:02.000Z","updated":"2020-06-27T14:13:10.667Z","comments":true,"path":"2019/10/31/hexo-blog-init/","link":"","permalink":"https://msnodeve.github.io/2019/10/31/hexo-blog-init/","excerpt":"Github Hexo Blog 만들어 보기ㅤ","text":"Github Hexo Blog 만들어 보기ㅤ 개발 환경 본 블로그는 Homebrew, iTerm 이 설치 되어있는 mac에서 진행 되었다는 점 참고 바랍니다. Blog를 만들기에 앞서 구성 환경 준비 Node.js, Git, npm을 설치하도록 하겠습니다. 12$ brew install node$ node -v Node.js가 정상적으로 설치 되었다면 다음과 같은 화면을 확인 할 수 있습니다 12$ brew install git$ git --version Git이 정상적으로 설치가 되었다면 다음과 같은 화면을 확인 할 수 있습니다 12$ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"$ npm -v npm이 정상적으로 설치가 되었다면 다음과 같은 화면을 확인 할 수 있습니다 npm을 이용해서 hexo 설치하기1$ npm install -g hexo-cli hexo가 정상적으로 설치가 되었다면 다음과 같은 화면을 확인 할 수 있습니다 Hexo 시작하기1234567891011121314151617$ hexo init testBlog$ cd testBlog$ npm install``` 다음과 같은 폴더 구조를 확인 할 수 있습니다&lt;div style=\"text-align: center;\"&gt;&lt;img src=\"/image/blog/blog6.png\" width=\"100%\"&gt;&lt;/div&gt;```text _config.yml 설정 파일 scaffolds 양식 source 초안, 포스트 폴더 themes 테마 폴더 package.json 로컬 에서 블로그를 실행해 보도록 하겠습니다 1$ hexo server http://localhost:4000 로 접속하게 되면 다음과 같은 화면을 확인 할 수 있습니다 포스트 작성하기1$ hexo new post [Post Name] ./source/_posts/ 폴더에 생성한 [Post Name] md 파일을 확인 할 수 있습니다 1$ hexo server hexo를 실행해 보면 [Post Name]이름으로 작성된 포스트를 확인 할 수 있습니다 Github 계정 URL 만들기Github Repo &gt; Settings &gt; Options &gt; Github Pages 의 site url를 정해 주도록 합니다. Github Repo에 배포 준비하기_config.yml 을 수정 하도록 하겠습니다 123456789101112131415161718192021# Sitetitle: [제목]subtitle: [부 제목]description: [설명]keywords: [키 워드]author: [저자]language: en [언어]timezone: Asia/Seoul [시간]# URLurl: https://msnodeve.github.io/ [위에서 정해준 Github url]root: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing index.html from permalinks# Deploymentdeploy: type: git repo: https://github.com/msnodeve/msnodeve.github.io.git [Github repo 주소] [참고] Github repo 주소는 아래와 같이 확인 할 수 있습니다 Github Repo에 빌드 및 배포하기123$ npm install hexo-deployer-git --save$ hexo generate$ hexo deploy hexo generate 와 hexo deploy 를 간략히 다음과 같이 표현 할 수 있습니다 1$ hexo g -d 로컬 에서 포스트 작성, 설정 및 변경을 하고 결과를 확인한 후, 빌드 및 배포하는 식으로 작업합니다 배포가 되면 msnodeve.github.io 으로 접속해서 확인합니다 그렇다고 로컬에서 변경된 사항이 Github Repo에 Commit 된 것은 아닙니다 따라서 최종적인 확인 끝에 변경 사항과 수정 사항을 체크하여 Commit을 하는 것이 좋습니다","categories":[{"name":"blog","slug":"blog","permalink":"https://msnodeve.github.io/categories/blog/"},{"name":"hexo","slug":"blog/hexo","permalink":"https://msnodeve.github.io/categories/blog/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://msnodeve.github.io/tags/hexo/"},{"name":"Blog","slug":"blog","permalink":"https://msnodeve.github.io/tags/blog/"}]},{"title":"Flask REST API CRUD Board Auth 그리고 암호화(5) - [Backend Framework]","slug":"flask-restapi-example5","date":"2019-08-06T04:32:06.000Z","updated":"2020-06-22T02:16:59.494Z","comments":true,"path":"2019/08/06/flask-restapi-example5/","link":"","permalink":"https://msnodeve.github.io/2019/08/06/flask-restapi-example5/","excerpt":"다섯번째 단계이번 포스트에서는 vscode 개발환경에서 Flask Framework Auth, 암호화에 대해서 알아보는 시간을 가져 보도록 하겠습니다. 플라스크 Flask vscode Framework 암호화 Auth","text":"INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5) 이번 포스트는 macOS Mojave 10.14.5 에서 수행된 작업입니다. 개발 환경 MacBook Pro (13-inch, 2017, Four Thunderbolt 3 Ports) Python 3.7 vscode Docker-Compose version 1.23.2, build 1110ad01 Authorization 붙이기 (PyJwt), Password 암호화먼저, 클라이언트 측에서 회원가입을 할 때, Password를 Database에 저장 때는 암호화 해서 넣어야 합니다(개발자가 사용자 비밀번호 까지 알아서 뭐 할려고?) 그러기 위해서는 Bcrypt를 사용해 암호화를 진행 할 것이며, 암호화 한 것을 Database에 저장하고, 사용자가 로그인 할 때, 서버에서 발급해주는 Token을 이용해 API를 사용할 것 입니다 Token이 없다면 API의 요청은 거절 하도록 만들 것 입니다 해봅시다! PyJwt 종속성을 설치합니다 1&gt; pipenv install PyJwt 데코레이터를 이용해서 구현한 API에 붙여 주도록 하곘습니다 12345678910111213141516171819202122232425262728293031323334353637383940# ./app/api/auth_type.pyimport jwtfrom flask import request, Responsefrom functools import wrapsSECERET_KEY = \"Secret Hellow\"ACCESS_TOKEN = &#123; 'Access Token': &#123; 'type': 'apiKey', 'in': 'header', 'name': 'Authorization' &#125;&#125;BASIC_AUTH = &#123; 'Basic Auth': &#123; 'type': 'basic', 'in': 'header', 'name': 'Authorization' &#125;,&#125;def confirm_token(f): @wraps(f) def decorated_function(*args, **kwargs): access_token = request.headers['Authorization'] if access_token is not None: try: payload = jwt.decode(access_token, SECERET_KEY, \"HS256\") except jwt.InvalidTokenError: payload = None if payload is None: return Response(status=401) user_id = payload[\"user_id\"] # 원하는 작업 else: return Response(status=401) return f(*args, **kwargs) return decorated_function REST API Documents에 Authorization을 보여주기 위해 위와 같은 코드를 작성하고,Token 발급을 위해 다음과 같이 코드를 작성하겠습니다 123456789101112131415# ./app/api/__init__.py\"\"\" API config file\"\"\"from flask_restplus import Apifrom app.users.views import API as users_apifrom app.posts.views import API as posts_apifrom app.api.auth_type import ACCESS_TOKEN, BASIC_AUTHREST_API = Api(authorizations=&#123;**ACCESS_TOKEN, **BASIC_AUTH&#125;)REST_API.add_namespace(users_api, '/user')REST_API.add_namespace(posts_api, '/post') 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# ./app/users/views.py\"\"\" User views file\"\"\"import jwtimport bcryptfrom http import HTTPStatusfrom flask import jsonify, make_responsefrom sqlalchemy.exc import SQLAlchemyErrorfrom flask_restplus import Namespace, Resource, reqparse, fieldsfrom app.users.models import Users, UsersSchemafrom app.api.database import DBfrom app.api.auth_type import SECERET_KEYAPI = Namespace('Users', description=\"User's RESTPlus - API\")USERS_SCHEMA = UsersSchema()@API.route('s')class UsersAuth(Resource): parser = reqparse.RequestParser() parser.add_argument('user_id', required=True, type=str, help=\"User's ID\", location='json') parser.add_argument('user_password', required=True, type=str, help=\"User's PW\", location='json') parser.add_argument('user_email', required=True, type=str, help=\"User's Email\", location='json') users_field = API.model('userRegister', &#123; 'user_id': fields.String, 'user_password': fields.String, 'user_email': fields.String &#125;) @API.doc('post') @API.expect(users_field) def post(self): args_ = self.parser.parse_args() password = args_['user_password'] hash_pw = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()) user = Users(args_['user_id'], hash_pw, args_['user_email']) return user.add(user, USERS_SCHEMA)@API.route('/auth')class UserAuth(Resource): parser = reqparse.RequestParser() parser.add_argument('user_id', required=True, type=str, help=\"User's ID\", location='json') parser.add_argument('user_password', required=True, type=str, help=\"User's PW\", location='json') user_login_field = API.model('userLogin', &#123; 'user_id': fields.String, 'user_password': fields.String &#125;) @API.doc('post') @API.expect(user_login_field) def post(self): args_ = self.parser.parse_args() try: user = Users.query.filter(Users.user_id == args_['user_id']).first() if bcrypt.checkpw(args_['user_password'].encode('utf-8'), user.user_password.encode('utf-8')): # token 발급 payload = &#123; 'user_id' : user.user_id &#125; token = jwt.encode(payload, SECERET_KEY, \"HS256\") body = jsonify(&#123;'access_token': token.decode('utf-8'),'user': user.id&#125;) if user: code = HTTPStatus.OK else: code = HTTPStatus.NOT_FOUND except SQLAlchemyError as err: body = jsonify(&#123;'message': str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) 발급한 Token을 클라이언트 측에서 저장을 한 뒤 발급받은 토큰을 서버로 Header 부분에 담아 데이터를 전송하여 맞으면 API요청을 받는 코드를 작성하도록 하겠습니다 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# /app/posts/views.py\"\"\" Posts view file\"\"\"from flask_restplus import Namespace, Resource, reqparse, fieldsfrom flask import jsonify, make_responsefrom http import HTTPStatusfrom sqlalchemy.exc import SQLAlchemyErrorfrom app.posts.models import Posts, PostsSchemafrom app.users.models import Users, UsersSchemafrom app.api.database import DBfrom app.api.auth_type import confirm_token, ACCESS_TOKEN, BASIC_AUTHAPI = Namespace('Posts', description=\"Post's REST API\")POSTS_SCHEMA = PostsSchema()@API.route('s')class Post(Resource): parser = reqparse.RequestParser() parser.add_argument('author_id', required=True, type=str, help=\"Post's author ID\", location='json') parser.add_argument('title', required=True, type=str, help=\"Post's title\", location='json') parser.add_argument('body', required=True, type=str, help=\"Post's body\", location='json') post_field = API.model('Post', &#123; 'author_id': fields.String, 'title': fields.String, 'body': fields.String &#125;) @API.doc('get') def get(self): try: posts = Posts.query.all() body = jsonify(POSTS_SCHEMA.dump(posts, many=True).data) if posts: code = HTTPStatus.OK else: code = HTTPStatus.NOT_FOUND except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) @API.expect(post_field) @confirm_token @API.doc('post', security=ACCESS_TOKEN) def post(self): args_ = self.parser.parse_args() post = Posts(author_id=args_['author_id'], title=args_['title'], body=args_['body']) return post.add(post, POSTS_SCHEMA)@API.route('/&lt;int:reqno&gt;')class PostItem(Resource): @confirm_token @API.doc('get', security=ACCESS_TOKEN) def get(self, reqno): try: post = DB.session.query(Posts).outerjoin( Users, Users.user_id == Posts.author_id).filter(Posts.id==reqno).first() body = POSTS_SCHEMA.dump(post).data if post: code = HTTPStatus.OK else: code = HTTPStatus.NOT_FOUND except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) Post Class의 post함수를 보게 되면 데코레이터로 confirm_token 을 붙인 것을 볼 수 있습니다 이 API로 요청이 왔을 때 먼저 토큰이 있는지 검사하고 통과 되면 Post함수를 실행하게 되는 구조입니다 실행을 해봅시다 1$ python manage.py run 아래와 같은 화면을 볼 수 있으며 각각 실행을 해보세요! 최종적인 폴더 구조는 다음과 같습니다 고생하셨습니다! 지금까지 따라와주셔서 정말 감사드리며 여기까지 하게 되면 Flask 프레임워크의 기본을 할 수 있게 된 것 입니다! INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"python","slug":"backend/framework/python","permalink":"https://msnodeve.github.io/categories/backend/framework/python/"},{"name":"flask","slug":"backend/framework/python/flask","permalink":"https://msnodeve.github.io/categories/backend/framework/python/flask/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Flask","slug":"flask","permalink":"https://msnodeve.github.io/tags/flask/"},{"name":"Python","slug":"python","permalink":"https://msnodeve.github.io/tags/python/"}]},{"title":"Flask REST API CRUD Board 만들기 MVC 그리고 REST API Swagger(4) - [Backend Framework]","slug":"flask-restapi-example4","date":"2019-08-05T04:07:25.000Z","updated":"2020-06-22T02:16:26.539Z","comments":true,"path":"2019/08/05/flask-restapi-example4/","link":"","permalink":"https://msnodeve.github.io/2019/08/05/flask-restapi-example4/","excerpt":"네번째 단계이번 포스트에서는 vscode 개발환경에서 Flask Framework MVC, Swagger API 문서 자동화에 대해서 알아보는 시간을 가져 보도록 하겠습니다. 플라스크 Flask vscode Framework Swagger MVC","text":"INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5) 이번 포스트는 macOS Mojave 10.14.5 에서 수행된 작업입니다. 개발 환경 MacBook Pro (13-inch, 2017, Four Thunderbolt 3 Ports) Python 3.7 vscode Docker-Compose version 1.23.2, build 1110ad01 RESTPlus 라이브러리를 사용해 REST API 만들기(Users Part)flask-restplus 종속성을 설치합니다 1$ pipenv install flask-restplus 이제 app에 설치한 RESTPlus를 달아 봅시다 1234567891011121314151617181920212223242526# ./app/__init__.py\"\"\" APP을 실행하기 위해 config file\"\"\"from flask import Flaskfrom app.api.database import DB, MAfrom app.api import REST_APIfrom app.constants import SQLALCHEMY_DATABASE_URI_FORMATdef create_app()-&gt;(Flask): \"\"\" create_app()을 호출하여 app을 초기화 \"\"\" app = Flask(__name__) app.app_context().push() app.config['SQLALCHEMY_DATABASE_URI'] = SQLALCHEMY_DATABASE_URI_FORMAT app.config['SQLALCHEMY_ECHO'] = True app.config['DEBUG'] = True DB.init_app(app) REST_API.init_app(app) MA.init_app(app) return app MVC 패턴을 이용해 User 부분을 작성합니다 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# ./app/users/views.py\"\"\" User views file\"\"\"from http import HTTPStatusfrom flask import jsonify, make_responsefrom sqlalchemy.exc import SQLAlchemyErrorfrom flask_restplus import Namespace, Resource, reqparse, fieldsfrom app.users.models import Users, UsersSchemafrom app.api.database import DBAPI = Namespace('Users', description=\"User's RESTPlus - API\")USERS_SCHEMA = UsersSchema()@API.route('s')class UsersAuth(Resource): parser = reqparse.RequestParser() parser.add_argument('user_id', required=True, type=str, help=\"User's ID\", location='json') parser.add_argument('user_password', required=True, type=str, help=\"User's PW\", location='json') parser.add_argument('user_email', required=True, type=str, help=\"User's Email\", location='json') users_field = API.model('Sign up', &#123; 'user_id' : fields.String, 'user_password' : fields.String, 'user_email' : fields.String &#125;) @API.doc('post') @API.expect(users_field) def post(self): args_ = self.parser.parse_args() user = Users(args_['user_id'], args_['user_password'], args_['user_email']) try: DB.session.add(user) DB.session.commit() body = jsonify(&#123;'users' : USERS_SCHEMA.dump(user).data&#125;) code = HTTPStatus.OK except SQLAlchemyError as err: DB.session.rollback() body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value)@API.route('/auth')class UserAuth(Resource): parser = reqparse.RequestParser() parser.add_argument('user_id', required=True, type=str, help=\"User's ID\", location='json') parser.add_argument('user_password', required=True, type=str, help=\"User's PW\", location='json') user_login_field = API.model('Sign in', &#123; 'user_id' : fields.String, 'user_password' : fields.String &#125;) @API.doc('post') @API.expect(user_login_field) def post(self): args_ = self.parser.parse_args() try: user = Users.query.filter(Users.user_id == args_['user_id']).first() body = jsonify(&#123;'user_id' : user.user_id&#125;) code = HTTPStatus.OK except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) Swagger를 달아 API를 호출 할수있는 Docs를 만듭시다 12345678# ./app/api/**init**.pyfrom flask_restplus import Apifrom app.users.views import API as users_apiREST_API = Api()REST_API.add_namespace(users_api, '/user') 앱을 한번 실행해 봅시다 1$ python manage.py run RESTPlus API 만들기(Posts Part)이전 포스트와 같이 Posts에 대한 Model을 만듭니다 1234567891011121314151617181920212223242526272829303132333435# ./app/posts/models.py\"\"\" Posts model file\"\"\"from app.api.database import DB, MAfrom marshmallow import Schema, fields, validatefrom app.users.models import Users, UsersSchemafrom sqlalchemy.sql import textclass Posts(DB.Model): __tablename__ = 'posts' __table_args__ = &#123;'mysql_collate': 'utf8_general_ci'&#125; id = DB.Column(DB.Integer, primary_key=True) author_id = DB.Column(DB.String(255), DB.ForeignKey(Users.user_id)) title = DB.Column(DB.String(512), nullable=False) body = DB.Column(DB.String(1024), nullable=False) author = DB.relationship('Users', uselist=False) created = DB.Column(DB.TIMESTAMP, server_default=text(\"CURRENT_TIMESTAMP\"), nullable=False) def __init__(self, author_id, title, body): self.author_id = author_id self.title = title self.body = bodyclass PostsSchema(MA.Schema): not_blank = validate.Length(min=1, error='Field cannot be blank') id = fields.Integer() author_id = fields.String(validate=not_blank) title = fields.String(validate=not_blank) body = fields.String(validate=not_blank) author = fields.Nested(UsersSchema) created = fields.String(validate=not_blank) MVC 패턴을 이용해 Posts 부분을 작성합니다 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# ./app/posts/views.py\"\"\" Posts view file\"\"\"from flask_restplus import Namespace, Resource, reqparse, fieldsfrom flask import jsonify, make_responsefrom http import HTTPStatusfrom sqlalchemy.exc import SQLAlchemyErrorfrom app.posts.models import Posts, PostsSchemafrom app.users.models import Users, UsersSchemafrom app.api.database import DBAPI = Namespace('Posts', description=\"Post's REST API\")POSTS_SCHEMA = PostsSchema()@API.route('s')class Post(Resource): parser = reqparse.RequestParser() parser.add_argument('author_id', required=True, type=str, help=\"Post's author ID\", location='json') parser.add_argument('title', required=True, type=str, help=\"Post's title\", location='json') parser.add_argument('body', required=True, type=str, help=\"Post's body\", location='json') post_field = API.model('Post', &#123; 'author_id': fields.String, 'title': fields.String, 'body': fields.String &#125;) @API.doc('get') def get(self): try: posts = Posts.query.all() body = jsonify(POSTS_SCHEMA.dump(posts, many=True).data) code = HTTPStatus.OK except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) @API.expect(post_field) @API.doc('post') def post(self): args_ = self.parser.parse_args() post = Posts(author_id=args_['author_id'], title=args_['title'], body=args_['body']) try: DB.session.add(post) DB.session.commit() body = jsonify(&#123;'post', POSTS_SCHEMA.dump(post).data&#125;) code = HTTPStatus.OK except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value)@API.route('/&lt;int:reqno&gt;')class PostItem(Resource): def get(self, reqno): try: post = DB.session.query(Posts).outerjoin( Users, Users.user_id == Posts.author_id).filter(Posts.id==reqno).first() body = jsonify(&#123;'post' : POSTS_SCHEMA.dump(post).data&#125;) code = HTTPStatus.OK except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) Swagger를 달아 API를 호출 할수있는 Docs를 만듭시다 123456789101112# ./app/api/__init__.py\"\"\" API config file\"\"\"from flask_restplus import Apifrom app.posts.views import API as posts_apiREST_API = Api()REST_API.add_namespace(users_api, '/user')REST_API.add_namespace(posts_api, '/post') MVC(Model, View, Controller) 분리12345678910111213141516171819202122232425262728293031323334# ./app/api/database.py\"\"\" Create db\"\"\"from flask import jsonifyfrom flask import make_responsefrom http import HTTPStatusfrom flask_sqlalchemy import SQLAlchemyfrom sqlalchemy.exc import IntegrityErrorfrom flask_marshmallow import MarshmallowDB = SQLAlchemy()MA = Marshmallow()class CRUD: body = '' status_code = HTTPStatus.NOT_IMPLEMENTED def add(self, resource, schema): try: DB.session.add(resource) DB.session.commit() self.body = jsonify(schema.dump(resource).data) self.status_code = HTTPStatus.OK except IntegrityError as err: DB.session.rollback() err_meg = str(err) self.body = jsonify(&#123;'error' : err_meg, 'type' : 'IntegrityError'&#125;) if \"Duplicate entry\" in err_meg: self.status_code = HTTPStatus.CONFLICT else: self.status_code = HTTPStatus.BAD_REQUEST return make_response(self.body, self.status_code) User, Post Model을 따로 빼 줍니다 1234567891011121314151617181920212223242526272829303132# ./app/users/models.py\"\"\" Users models file\"\"\"from sqlalchemy.sql import textfrom app.api.database import DB, MA, CRUDfrom flask_sqlalchemy import SQLAlchemyfrom marshmallow import Schema, fields, validateclass Users(DB.Model, CRUD): __tablename__ = 'users' __table_args__ = &#123;'mysql_collate': 'utf8_general_ci'&#125; id = DB.Column(DB.Integer, primary_key=True) user_id = DB.Column(DB.String(255), unique=True, nullable=False) user_password = DB.Column(DB.String(255), nullable=False) user_email = DB.Column(DB.String(255), nullable=False) created = DB.Column(DB.TIMESTAMP, server_default=text(\"CURRENT_TIMESTAMP\"), nullable=False) def __init__(self, user_id : str, user_password : str, user_email : str): self.user_id = user_id self.user_password = user_password self.user_email = user_emailclass UsersSchema(MA.Schema): not_blank = validate.Length(min=1, error='Field cannot be blank') id = fields.Integer(dump_only=True) user_id = fields.String(validate=not_blank) user_password = fields.String(validate=not_blank) user_email = fields.String(validate=not_blank) created = fields.String(validate=not_blank) 1234567891011121314151617181920212223242526272829303132333435# ./app/posts/models.py\"\"\" Posts model file\"\"\"from app.api.database import DB, MA, CRUDfrom marshmallow import Schema, fields, validatefrom app.users.models import Users, UsersSchemafrom sqlalchemy.sql import textclass Posts(DB.Model, CRUD): __tablename__ = 'posts' __table_args__ = &#123;'mysql_collate': 'utf8_general_ci'&#125; id = DB.Column(DB.Integer, primary_key=True) author_id = DB.Column(DB.String(255), DB.ForeignKey(Users.user_id)) title = DB.Column(DB.String(512), nullable=False) body = DB.Column(DB.String(1024), nullable=False) author = DB.relationship('Users', uselist=False) created = DB.Column(DB.TIMESTAMP, server_default=text(\"CURRENT_TIMESTAMP\"), nullable=False) def __init__(self, author_id, title, body): self.author_id = author_id self.title = title self.body = bodyclass PostsSchema(MA.Schema): not_blank = validate.Length(min=1, error='Field cannot be blank') id = fields.Integer() author_id = fields.String(validate=not_blank) title = fields.String(validate=not_blank) body = fields.String(validate=not_blank) author = fields.Nested(UsersSchema) created = fields.String(validate=not_blank) view 부분도 빼 줍시다 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# ./app/users/views.py\"\"\" User views file\"\"\"from http import HTTPStatusfrom flask import jsonify, make_responsefrom sqlalchemy.exc import SQLAlchemyErrorfrom flask_restplus import Namespace, Resource, reqparse, fieldsfrom app.users.models import Users, UsersSchemafrom app.api.database import DBAPI = Namespace('Users', description=\"User's RESTPlus - API\")USERS_SCHEMA = UsersSchema()@API.route('s')class UsersAuth(Resource): parser = reqparse.RequestParser() parser.add_argument('user_id', required=True, type=str, help=\"User's ID\", location='json') parser.add_argument('user_password', required=True, type=str, help=\"User's PW\", location='json') parser.add_argument('user_email', required=True, type=str, help=\"User's Email\", location='json') users_field = API.model('userRegister', &#123; 'user_id' : fields.String, 'user_password' : fields.String, 'user_email' : fields.String &#125;) @API.doc('post') @API.expect(users_field) def post(self): args_ = self.parser.parse_args() user = Users(args_['user_id'], args_['user_password'], args_['user_email']) return user.add(user, USERS_SCHEMA)@API.route('/auth')class UserAuth(Resource): parser = reqparse.RequestParser() parser.add_argument('user_id', required=True, type=str, help=\"User's ID\", location='json') parser.add_argument('user_password', required=True, type=str, help=\"User's PW\", location='json') user_login_field = API.model('userLogin', &#123; 'user_id' : fields.String, 'user_password' : fields.String &#125;) @API.doc('post') @API.expect(user_login_field) def post(self): args_ = self.parser.parse_args() try: user = Users.query.filter(Users.user_id == args_['user_id'], Users.user_password == args_['user_password']).first() body = jsonify(&#123;'user_id' : user.user_id&#125;) if user: code = HTTPStatus.OK else: code = HTTPStatus.NOT_FOUND except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# ./app/posts/views.py\"\"\" Posts view file\"\"\"from flask_restplus import Namespace, Resource, reqparse, fieldsfrom flask import jsonify, make_responsefrom http import HTTPStatusfrom sqlalchemy.exc import SQLAlchemyErrorfrom app.posts.models import Posts, PostsSchemafrom app.users.models import Users, UsersSchemafrom app.api.database import DBAPI = Namespace('Posts', description=\"Post's REST API\")POSTS_SCHEMA = PostsSchema()@API.route('s')class Post(Resource): parser = reqparse.RequestParser() parser.add_argument('author_id', required=True, type=str, help=\"Post's author ID\", location='json') parser.add_argument('title', required=True, type=str, help=\"Post's title\", location='json') parser.add_argument('body', required=True, type=str, help=\"Post's body\", location='json') post_field = API.model('Post', &#123; 'author_id': fields.String, 'title': fields.String, 'body': fields.String &#125;) @API.doc('get') def get(self): try: posts = Posts.query.all() body = jsonify(POSTS_SCHEMA.dump(posts, many=True).data) if posts: code = HTTPStatus.OK else: code = HTTPStatus.NOT_FOUND except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) @API.expect(post_field) @API.doc('post') def post(self): args_ = self.parser.parse_args() post = Posts(author_id=args_['author_id'], title=args_['title'], body=args_['body']) return post.add(post, POSTS_SCHEMA)@API.route('/&lt;int:reqno&gt;')class PostItem(Resource): def get(self, reqno): try: post = DB.session.query(Posts).outerjoin( Users, Users.user_id == Posts.author_id).filter(Posts.id==reqno).first() body = POSTS_SCHEMA.dump(post).data if post: code = HTTPStatus.OK else: code = HTTPStatus.NOT_FOUND except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) 이제 최종적으로 실행을 해봅시다 1$ python manage.py run INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"python","slug":"backend/framework/python","permalink":"https://msnodeve.github.io/categories/backend/framework/python/"},{"name":"flask","slug":"backend/framework/python/flask","permalink":"https://msnodeve.github.io/categories/backend/framework/python/flask/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Flask","slug":"flask","permalink":"https://msnodeve.github.io/tags/flask/"},{"name":"Python","slug":"python","permalink":"https://msnodeve.github.io/tags/python/"}]},{"title":"Flask REST API CRUD Board ORM 그리고 Model(3) - [Backend Framework]","slug":"flask-restapi-example3","date":"2019-08-04T11:15:52.000Z","updated":"2020-06-22T02:15:21.404Z","comments":true,"path":"2019/08/04/flask-restapi-example3/","link":"","permalink":"https://msnodeve.github.io/2019/08/04/flask-restapi-example3/","excerpt":"세번째 단계이번 포스트에서는 vscode 개발환경에서 Flask Framework ORM, Model에 대해서 알아보는 시간을 가져 보도록 하겠습니다. 플라스크 Flask vscode Framework ORM Model","text":"INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5) 이번 포스트는 macOS Mojave 10.14.5 에서 수행된 작업입니다. 개발 환경 MacBook Pro (13-inch, 2017, Four Thunderbolt 3 Ports) Python 3.7 vscode Docker-Compose version 1.23.2, build 1110ad01 Model 만들기, ORM 적용SQLAlchemy, Marshmallow 종속성을 설치합니다 1$ pipenv install flask_sqlalchemy flask-marshmallow Flask-Migrate pymysql 환경변수를 작성합니다 1234567891011121314# ./app/constants.py 생성\"\"\" 상수 클래스\"\"\"SQLALCHEMY_DATABASE_URI = (\"mysql+pymysql://&#123;USER&#125;:&#123;PASSWORD&#125;@&#123;ADDR&#125;:&#123;PORT&#125;/&#123;NAME&#125;?charset=utf8\")SQLALCHEMY_DATABASE_URI_FORMAT = SQLALCHEMY_DATABASE_URI.format( USER=\"[사용자 ID]\", PASSWORD=\"[사용자 PW]\", ADDR=\"127.0.0.1\", PORT=3306, NAME=\"[사용할 DB]\" ) 이제 app에 설치한 SQLAlchemy, Marshmallow를 달아 봅시다 12345678910111213141516171819202122232425262728# ./app/__init__.py\"\"\" APP을 실행하기 위해 config file\"\"\"from flask import Flaskfrom app.api.database import DB, MAfrom app.constants import SQLALCHEMY_DATABASE_URI_FORMATdef create_app()-&gt;(Flask): \"\"\" create_app()을 호출하여 app을 초기화 \"\"\" app = Flask(__name__) app.app_context().push() app.config['DEBUG'] = True app.config['SQLALCHEMY_ECHO'] = True app.config['SQLALCHEMY_DATABASE_URI'] = SQLALCHEMY_DATABASE_URI_FORMAT DB.init_app(app) MA.init_app(app) @app.route('/') def root(): \"\"\" main page \"\"\" return \"Hello World!\" return app 1234567891011121314151617181920212223242526272829# ./manage.py\"\"\" APP manage file\"\"\"from flask_script import Managerfrom flask_migrate import Migrate, MigrateCommandfrom app import create_appfrom app.api.database import DBfrom app.users.models import Users, UsersSchemaAPP = create_app()MANAGER = Manager(APP)MIGRATE = Migrate(APP, DB)MANAGER.add_command('db', MigrateCommand)@MANAGER.commanddef run(): \"\"\" Command Application run \"\"\" APP.run()@MANAGER.commanddef out(): \"\"\" test command out method \"\"\" return \"Test command\"if __name__ == '__main__': MANAGER.run() Database에 User 모델을 ORM으로 설계합니다User 모델을 작성합니다 1234567891011121314151617181920212223242526272829303132# ./app/users/models.py\"\"\" Users models file\"\"\"from sqlalchemy.sql import textfrom app.api.database import DB, MAfrom flask_sqlalchemy import SQLAlchemyfrom marshmallow import Schema, fields, validateclass Users(DB.Model): __tablename__ = 'users' __table_args__ = &#123;'mysql_collate': 'utf8_general_ci'&#125; id = DB.Column(DB.Integer, primary_key=True) user_id = DB.Column(DB.String(255), unique=True, nullable=False) user_password = DB.Column(DB.String(255), nullable=False) user_email = DB.Column(DB.String(255), nullable=False) created = DB.Column(DB.TIMESTAMP, server_default=text(\"CURRENT_TIMESTAMP\"), nullable=False) def __init__(self, user_id, user_password, user_email): self.user_id = user_id self.user_password = user_password self.user_email = user_emailclass UsersSchema(MA.Schema): not_blank = validate.Length(min=1, error='Field cannot be blank') id = fields.Integer(dump_only=True) user_id = fields.String(validate=not_blank) user_password = fields.String(validate=not_blank) user_email = fields.String(validate=not_blank) created = fields.String(validate=not_blank) 1234567891011# ./app/api/database.py\"\"\" Create db\"\"\"from flask_sqlalchemy import SQLAlchemyfrom flask_marshmallow import MarshmallowDB = SQLAlchemy()MA = Marshmallow() 설계한 ORM을 데이터베이스에 적용 시킵니다 db라는 커맨드로 추가해줬으니 init으로 migrations 폴더를 생성합니다 1$ python manage.py db init 이렇게 해준 뒤 데이터베이스를 보게 되면 다음과 같은 화면을 볼 수 있습니다 이는 데이터베이스만 생성시키는 작업을 합니다 현재 모델에 대한 모든 변경 사항을 감지를 못하고, 스크립트를 검토해 Database에 적용 시킵니다 1$ python manage.py db migrate 이러면 테이블이 생긴 모습을 확인할 수 있습니다 ORM구조가 변경 될 경우데이터베이스 모델이 변경 될 때마다 migrate, upgrade를 해주어야 합니다테이블을 동기화 하기 위해서요 1$ python manage.py db upgrade 현재까지의 폴더 구조는 아래와 같습니다 INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"python","slug":"backend/framework/python","permalink":"https://msnodeve.github.io/categories/backend/framework/python/"},{"name":"flask","slug":"backend/framework/python/flask","permalink":"https://msnodeve.github.io/categories/backend/framework/python/flask/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Flask","slug":"flask","permalink":"https://msnodeve.github.io/tags/flask/"},{"name":"Python","slug":"python","permalink":"https://msnodeve.github.io/tags/python/"}]},{"title":"Flask REST API CRUD Board 만들기 설정 및 MySQL(2) - [Backend Framework]","slug":"flask-restapi-example2","date":"2019-08-01T01:56:00.000Z","updated":"2020-06-22T02:14:38.293Z","comments":true,"path":"2019/08/01/flask-restapi-example2/","link":"","permalink":"https://msnodeve.github.io/2019/08/01/flask-restapi-example2/","excerpt":"두번째 단계이번 포스트에서는 vscode 개발환경에서 Flask Framework 설정 및 MySQL에 관하여 알아보는 시간을 가져 보도록 하겠습니다. 플라스크 Flask vscode Framework MySQL 설정","text":"INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5) 이번 포스트는 macOS Mojave 10.14.5 에서 수행된 작업입니다. 개발 환경 MacBook Pro (13-inch, 2017, Four Thunderbolt 3 Ports) Python 3.7 vscode Docker-Compose version 1.23.2, build 1110ad01 Manager 사용하기12345678910111213141516171819# ./app/__init__.py\"\"\" APP을 실행하기 위해 config file\"\"\"from flask import Flaskdef create_app()-&gt;(Flask): \"\"\" create_app()을 호출하여 app을 초기화 \"\"\" app = Flask(__name__) app.app_context().push() @app.route('/') def root(): \"\"\" main page \"\"\" return \"Hello World!\" return app Flask-Script 종속성을 설치합니다 1$ pipenv install Flask-Script 12345678910111213141516171819202122232425# ./manage.py\"\"\" APP manage file\"\"\"from flask_script import Managerfrom app import create_app # app/__init__.py의 create_app() 함수 사용APP = create_app()MANAGER = Manager(APP)@MANAGER.commanddef run(): \"\"\" Command Application run \"\"\" APP.run()@MANAGER.commanddef out(): \"\"\" test command out method \"\"\" return \"Test command\"if __name__ == '__main__': MANAGER.run() 작성해 놓은 커맨드를 한번 확인해 볼까요? 12345678910111213$ python manage.pyusage: manage.py [-?] &#123;run,out,shell,runserver&#125; ...positional arguments: &#123;run,out,shell,runserver&#125; run Command Application run out test command out method shell Runs a Python shell inside Flask application context. runserver Runs the Flask development server i.e. app.run()# def out(), def run()에 대한 커맨드가 생긴 것을 볼 수 있습니다!optional arguments: -?, --help show this help message and exit 이제 실행을 다시 해볼까요? 1234567$ python manage.py run * Serving Flask app \"app\" (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on &lt;http://127.0.0.1:5000/$ (Press CTRL+C to quit) MySQL 사용하기 위한 작업Docker가 필요한 시점입니다 Docker를 설치해주세요Docker 설치 관련 포스트 123456789101112131415161718# ./docker-compose.yml 생성version: '3'services: # 쓰고자하는 서비스 mysql: # 사용자가 원하는 이름 image: mysql:5.7 # 이미지는 mysql 5.7을 다운받아 사용할 것 hostname: mysql container_name: mysql command: --default-authentication-plugin=mysql_native_password restart: always # 시스템을 다시 껐다 켜도 항상 재시작 ports: - \"3306:3306\" # 23306 포트로 접속하면 내부에서 3306포트로 전송 env_file: - ./confs/database/mysql/.env # 환경 변수들을 따로 지정해줘도 되지만 파일로 떼어놓음 volumes: - mysql:/var/lib/mysql # docker 접속후 이 위치로 마운트(destination)volumes: mysql: MySQL 환경 변수를 작성 하겠습니다 123456# ./confs/database/mysql/.env 생성MYSQL_DATABASE_USERNAME=[데이터 베이스 사용자 이름]MYSQL_ROOT_PASSWORD=[데이터 베이스 루트 비밀 번호]MYSQL_DATABASE=[생성할 데이터베이스 이름]MYSQL_PORT=3306 Docker로 MySQL 생성하고 접속하기docker-compose.yml 위치가 있는 곳에서 다음 명령어를 실행합니다 12$ docker-compose up -dCreating mysql ... done done 이라는 단어가 보인다면 성공적으로 MySQL Conatainer를 생성한 것입니다만약 실패했다면 3306 포트가 사용중이 아닌지 확인해 주세요!(또는 댓글로 알려주세요) MySQL WorkBench를 이용해서 접속하기 Successfully made the MySQL connection 뜬다면 접속 성공! 생성된 데이터베이스에 접속해보면 다음과 같은 화면을 볼수 있습니다 INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"python","slug":"backend/framework/python","permalink":"https://msnodeve.github.io/categories/backend/framework/python/"},{"name":"flask","slug":"backend/framework/python/flask","permalink":"https://msnodeve.github.io/categories/backend/framework/python/flask/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Flask","slug":"flask","permalink":"https://msnodeve.github.io/tags/flask/"},{"name":"Python","slug":"python","permalink":"https://msnodeve.github.io/tags/python/"}]},{"title":"Flask REST API CRUD Board 만들기 실행(1) - [Backend Framework]","slug":"flask-restapi-example1","date":"2019-07-30T06:26:28.000Z","updated":"2020-06-22T02:05:39.329Z","comments":true,"path":"2019/07/30/flask-restapi-example1/","link":"","permalink":"https://msnodeve.github.io/2019/07/30/flask-restapi-example1/","excerpt":"첫번째 단계이번 포스트에서는 vscode 개발환경에서 Flask Framework 프로젝트를 생성하고 실행해보는 시간을 가져 보도록 하겠습니다. 플라스크 Flask vscode Framework 프로젝트 생성하는 방법!","text":"INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5) 이번 포스트는 macOS Mojave 10.14.5 에서 수행된 작업입니다. 개발 환경 MacBook Pro (13-inch, 2017, Four Thunderbolt 3 Ports) Python 3.7 vscode Docker-Compose version 1.23.2, build 1110ad01 왜 Flask 프레임워크를 쓰려고 정했는가?Django보다 좀 더 경량화 된 프레임워크라고 보시면 됩니다 그리고 REST API를 경험해보기에 딱 적당한 프레임워크라고 생각 되었습니다 Pipfile 생성pipenv = pip + virtualenv 동시에 사용하고자, Python.org 에서 공식적으로 권장하는 Python 패키지 툴입니다 Pipfile을 생성합니다 1$ pipenv --three Pipfile 필요한 패키지 설치개발에 필요한 패키지 설치 1$ pipenv install pytest-cov pytest pylint --dev 배포에 필요한 패키지 설치 1$ pipenv install flask 그림을 보시면 개발에 필요한 패키지를 설치할 경우 [dev-packages]에 배포에 필요한 패키지를 설치할 경우 [packages] 에 라이브러리가 설치 된 모습을 확인할 수 있습니다 가상 환경 진입1234567$ vi .envrcexport PIPENV_VENV_IN_PROJECT=.esc + wq!$ direnv allow$ pipenv shell$ pipenv sync 위 환경 변수 파일을 allow 하지 않으면 다음과 같이 비슷한 곳에서 activate 됩니다 1❯ . /Users/seok/.local/share/virtualenvs/example2-CgPABPw3/bin/activate 정확하게 되었다면 다음 사진과 같은 모습을 볼 수 있습니다 초기 프로젝트 뼈대 구조아래와 같이 구조를 잡아 줍시다 간단하게 APP 실행12345678910111213141516# ./manage.py 생성 (manage.py의 코드는 임시로 작성해놓음)\"\"\" APP manage 파일\"\"\"from flask import FlaskAPP = Flask(__name__)@APP.route('/')def main(): return \"Hello World!\"if __name__ == '__main__': APP.run() 실행해 봅시다 1234567$ python manage.py * Serving Flask app \"manage\" (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on &lt;http://127.0.0.1:5000/$ (Press CTRL+C to quit) Flask는 Port를 적어주지않으면 5000번 Port로 기본 설정이 됩니다 (포트를 변경하고 싶으면 APP.run(port=[Port]) 로 실행하면 됩니다) http://127.0.0.1:5000/ 로 접속 화면 INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"python","slug":"backend/framework/python","permalink":"https://msnodeve.github.io/categories/backend/framework/python/"},{"name":"flask","slug":"backend/framework/python/flask","permalink":"https://msnodeve.github.io/categories/backend/framework/python/flask/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Flask","slug":"flask","permalink":"https://msnodeve.github.io/tags/flask/"},{"name":"Python","slug":"python","permalink":"https://msnodeve.github.io/tags/python/"}]},{"title":"AWS EC2에 대해서 알아보기 - [Cloud Infra]","slug":"cloud-aws-ec2","date":"2019-05-01T11:06:14.000Z","updated":"2020-06-23T01:16:59.361Z","comments":true,"path":"2019/05/01/cloud-aws-ec2/","link":"","permalink":"https://msnodeve.github.io/2019/05/01/cloud-aws-ec2/","excerpt":"AWS가 뭐야?이번 포스트에서는 AWS(Amazon Web Services)에 대해서 알아보는 시간을 가져 보도록 하겠습니다. AWS Amazon Web Services Infra 비용은? 이게뭔데!","text":"EC2(Elastic Compute Cloud)이전 포스트에서 AWS의 컴퓨터 한 대를 ‘빌려’ 쓴다고 했습니다 그럼 이제 직접 빌려봐야 하지 않을까요!? 빌려 써보도록 합시다그럼 지금부터 AWS의 EC2를 생성해서 접속까지 하는 것을 해보도록 하겠습니다본 블로그는 12개월 무료인 프리 티어에 대해서 설명드리며, 또 한 이번 포스트는 AWS에 이미 가입되어 있는 상태에서 진행되는 점 알려드립니다. 서비스 &gt; 컴퓨팅 &gt; EC2 Region - 서울 이 되어있는지를 확인합니다 (이유는 제일 아래 설명합니다)인스턴스 &gt; 인스턴스 생성 Amazon Linux &gt; 선택프리 티어에서도 스크롤을 아래로 내려다보면 여러 가지 인스턴스 들을 생성할 수 있습니다그중에 우리는 리눅스 인스턴스를 생성해서 접속해 보도록 하겠습니다 유형 - t2.micro (프리 티어 사용 가능) 확인검토 및 시작 (세부 설정은 지금은 필요 없으니 넘어가도록 합니다)이렇게 하면 1개의 CPU, 1GB 메모리가 달린 EC2 컴퓨터를 장만하기 시작합니다다른 유형에 대해서는 프리티 어가 아닌 경우 시간 또는 분 단위로 요금이 나옵니다 이 경우에 대해서는 제일 아래에서 설명하겠습니다 시작하기 새 키 페어 생성.pem이라는 확장자를 가진 키, 잃어버리지 않도록 주의하며 키 이름을 설정하고 다운로드인스턴스 시작키 페어는 오직 지금 밖에 다운로드만 가능합니다 그러니 잃어 버리지 않도록 주의! 잃어버렸을 경우 방법이 있지만 여기서는 설명하지 않도록 하겠습니다 (그냥 잃어버리지 말길 바래요…) 시작한 뒤 인스턴스를 보게 되면 Pending 이였다가 잠시 뒤 running으로 바뀌게 됩니다이 상태가 되면 우리는 지금 AWS의 컴퓨터 한 대를 장만하게 됐어요! 참 쉽죠?지금부터 EC2를 시작했으니 돈이 나가기 시작할 거예요 그러나 걱정하지 말죠! 우리는 12개월 동안 무료로 사용할 수 있는 프리 티어이니까! 자 이제 인스턴스가 돈이 안 나가게 하는 방법에 대해서 알아봅시다 해당 인스턴스 오른쪽 클릭 &gt; 인스턴스 상태 &gt; 중지이렇게 하면 해당 인스턴스가 최소 몇 초에서 최대 5분 내로 인스턴스의 상태가 Stopped의 상태가 됩니다 이제 EC2 인스턴스를 생성하고 껐다 켰다를 할 수 있게 되었습니다 이제 EC2에 접속을 해봐야 하지 읺을까요? Mac OS X에서 접속하는 방법과 Windows 10에서 접속하는 방법. 이 두 가지에 대해서 설명하겠습니다! Mac OS X 접속 방법 생성한 인스턴스 클릭 &gt; 퍼블릭 DNS 기억 터미널 오픈 &gt; 인스턴스를 생성할 때 다운로드 받은 키가 존재하는 폴더로 이동 1234$ chmod 400 &lt;다운로드 받은 키.pem&gt;SSH가 작동하려면 키가 공개적으로 표시되지 않아야 한다. 필요할 경우 이 명령을 사용.$ sudo ssh -i &quot;&lt;다운로드 받은 키.pem&gt;&quot; &lt;본인 인스턴스의 퍼블릭 DNS&gt;sudo 명령어로 관리자 권한으로 실행을 하게 될 시 비밀번호를 물어본다. 이 경우 Mac 비밀번호이다. Windows 10 접속 방법제 블로그에서는 Putty 프로그램을 이용해서 접속을 할 것입니다시작 &gt; 모든 프로그램 &gt; puTTY &gt; PuTTYgen 선택 생성 키의 종류 - RSALoad All Files(*.*) &gt; &quot;다운로드 받은 키&quot;Save Private Key(PuTTY가 사용할수 있는 형식으로 .ppk 비공개 키 저장) Host Name(or IP address) : 본인의 인스턴스의 퍼블릭 DNSPort : 22Connection type : SSHCategory &gt; Connection &gt; SSH &gt; auth Browse.. &gt; 비공개로 저장했던 키를 검색Open SSH를 서버에 등록하겠냐는 문구가 뜨면 당연히 Yes를 클릭하고 로그인한다.로그인 ID : ec2-user 수고하셨습니다여러분들은 이제 AWS의 컴퓨터 한대를 빌려 접속을 성공했습니다 다음으론 EC2 요금에 대해서 한번 알아보도록 하겠습니다당연하겠지만 빌려 쓰는 것이기 때문에 사용료를 지불해야 합니다 사용하는 방식(비용을 지불하려고 하는 형태)에는 4가지의 방식이 있어요AWS 요금 형식 링크를 들어가 보면 4가지의 요금 형식이 있지만 2가지만 설명하겠습니다 1. 온디멘드실행되고 있는 인스턴스에 따라 대게 시간당으로 비용을 지불하게 됩니다 2. 예약 인스턴스인스턴스를 실행하는 것을 예약으로 설정하여 만약 어느 수요가 많다는 생각이 드는 시간대에 온 디멘드 방식보단 예약 인스턴스를 방식을 사용하여 계속 켜놓는 것보다 필요할 때만 인스턴스를 켜기 때문에 비용을 최대 `75% 정도`까지 절약할 수 있습니다 나머지 2가지 방식은 독자께서 이해해보려 노력하길 바라며 (총총…) EC2에 대한 다양한 요금 이 그림을 보고 간단하게 설명하고 넘어갈게요 프리 티어 기준으로 생성한 인스턴스를 보도록 하겠습니다보다시피 CPU 1개, 메모리 1GB 짜리를 사용하는데 시간당 요금이 시간당 0.0144 USD 즉, 1달러(한화 약 1200원)를 쓰려면 69.4시간을 사용해야 1달러가 나온다는 말입니다이 말이 무슨 말이냐고요? 저는 정말 멍청한 짓을 했죠ㅠ 서버 컴퓨터 하나 맞추려고 50만 원 정도의 돈을 투자해서 맞췄는데… 단돈 1200원이라는 돈으로 70시간의 컴퓨터를 빌릴 수 있다니… 여기서 새삼 한 번 더 AWS에 대해 놀랬습니다물론 본인이 개인 서비스를 진행하고자 하는데 사용자 수가 많아지면 당연히 그림에 나와 있는 사양 가지고는 터무니가 없다고 느낄 것입니다 그래서 밑으로 내려다보면 자신에게 맞는 사양을 택해서 요금을 내면 됩니다 다른 사양에 대해서는 잘 보도록 하길 바래요 지역(Region)에 대해서 설명 AWS region 참조 관련 이미지비용 지불 형식에 대해서 이해했다면 이제 이전 포스트에 말했던 Region에 관해서 설명을 하고자 합니다위를 봤던 그림처럼 여러 Region에 AWS가 있다고 했습니다 나중에 보면 알겠지만 내가 한국에 있다고 꼭 서울 Region을 선택해서 사용할 필요는 없습니다 이러한 Region을 정하는 기준에 대해서는 이렇게 생각하면 좋겠습니다“내가 프로그램을 제작하였을 때 이 프로그램을 어느 Region에 있는 사용자가 많이 사용할 것인가?” 이러한 질문에서 당연히 한국 사람들이 많이 사용할 것이라면 서울 Region을 선택해서 사용하면 되고, 유럽 사람들이 많이 사용할 것이라면 유럽 Region을 선택해서 사용하면 됩니다 왜냐하면 한국 사람들이 많이 사용하는데 유럽 Region을 선택해서 사용하다 보면 한국에서 유럽까지 통신하는 거리가 있기 때문에 조금 느릴 수가 있어요 (Region 선택은 본인이 선택하는 것이기 때문에 느리든 말든 알아서 해도 무관하다… 제 생각은 그렇다는 거예요)","categories":[{"name":"infra","slug":"infra","permalink":"https://msnodeve.github.io/categories/infra/"},{"name":"aws","slug":"infra/aws","permalink":"https://msnodeve.github.io/categories/infra/aws/"},{"name":"cloud","slug":"infra/aws/cloud","permalink":"https://msnodeve.github.io/categories/infra/aws/cloud/"}],"tags":[{"name":"Infra","slug":"infra","permalink":"https://msnodeve.github.io/tags/infra/"},{"name":"AWS","slug":"aws","permalink":"https://msnodeve.github.io/tags/aws/"},{"name":"Cloud","slug":"cloud","permalink":"https://msnodeve.github.io/tags/cloud/"}]},{"title":"AWS? AWS가 뭐야? - [Cloud Infra]","slug":"cloud-aws","date":"2019-04-26T10:42:56.000Z","updated":"2020-06-23T01:16:10.518Z","comments":true,"path":"2019/04/26/cloud-aws/","link":"","permalink":"https://msnodeve.github.io/2019/04/26/cloud-aws/","excerpt":"AWS가 뭐야?이번 포스트에서는 AWS(Amazon Web Services)에 대해서 알아보는 시간을 가져 보도록 하겠습니다. AWS Amazon Web Services Infra 비용은? 이게뭔데!","text":"AWS(Amazon Web Services)요즘 클라우드에 많은 관심을 갖고 있거나 서버를 다뤄본 개발자라면… 아마 AWS라는 단어를 들어보았을 겁니다제가 왜 AWS를 사용하게 되었는지부터 설명하겠습니다서버에 대한 기본 배경지식은 2018년 여름방학 때 부산 ETRI 연구연수생으로 인턴 과정을 하며 서버(리눅스 운영체제 기반 ; CentOS7기준)를 알게 되었고, 이로 인해 서버는 컴퓨터 한 대가 필요하다는 것을 느끼게 되었습니다당시 AWS의 존재조차 모르고 있었던 3학년 이였고 졸업을 1년 앞둔 저는 졸업작품을 제작해야 한다는 과제를 마주하게 되었습니다 그래도 안드로이드 애플리케이션을 건드릴 줄 알고 있던 저는 애플리케이션을 제작해서 졸업 과제를 수행해야겠다는 생각을 하게 되었습니다2명의 디자이너와 5명의 디벨로퍼로 내가 메인 디벨로퍼 겸 팀장을 맡아 팀원에게 할 일을 분배하며 팀 프로젝트를 진행하고 있었으며 시작은 좋았고(기획은 그럴싸했고 아이디어도 좋다는 생각이 듦), 기능 구현도 매우 훌륭하게 진행되고 있었습니다(클라이언트 만..)기획 때 클라이언트 부분을 깊게 생각하며 기획을 진행했었고, 서버 부분은 틀만 잡아놓고 나중에 천천히 구조를 짜야 겠다고 했습니다 사용자가 늘어감에 따라 서버와 어떻게 통신을 해야 할지 서버 구조는 어떻게 짜야 할지에 대해 아무런 구조를 짜놓은 상태가 아니었습니다 기능 구현이 점차 점차 완성됨에 따라 서버가 필요했고, 그로 인해 저는 서버용 컴퓨터를 한대 사야겠다는 결심을 내린 뒤 무작정 부품들을 하나하나 사기 시작했습니다 맞춘 컴퓨터의 사양은 다음과 같았습니다 글을 읽는 사람들 중 서버로 사용하기에 “엥?” 하는 사람 물론 있을 것입니다 알고 있습니다… 저는 그냥 컴퓨터 한 대가 필요했고 서버에 대한 적합한 사양을 몰랐었습니다 그래도 이러한 컴퓨터를 기반으로 서버에 대해서 많은 것을 알게 되었으니 저는 만족합니다 주문으로 온 부품들을 하나하나 조립했고, 운영체제는 CentOS7을 설치했습니다 배웠던 기본 지식으로 서버 세팅을 완료하고 안드로이드와 서버 통신을 하기 시작했다. 이때 사용한 기술 스택은 다른 포스트에서 설명하도록 하겠습니다어느 한날 같은 연구실 졸업 선배가 밥을 사준다고 나오라고 했으며, 그때 졸업작품에 대해서 이야기를 시작했습니다 클라이언트와 서버가 잘 통신되고 있던 저에게 선배가 다음과 같은 말을 했습니다 “왜 너는 굳이 노동을 하고 있느냐? 요즘 클라우드 서비스가 대세인데 하나 한 세팅을 언제 하며 몇 번의 클릭만으로 지금까지 구현해놓은 서비스를 다 할 수 있을 텐데 왜 그렇게 시간 낭비를 하고 있냐?”라고… 서버 컴퓨터는 당연히 있어야 통신을 하는 건 알고 있겠으려니 하며 그 말을 들은 저는 한편으론 의아해하며 또 한편으론 신기했습니다 조금만 익숙해지면 충분히 사용 가능하다며 저에게 제안을 했고, 다음날부터 AWS에 대해 알아가기 시작했습니다알아가면 알아갈수록 정말 신기했습니다… 제가 정작 3시간이 걸려 컴퓨터 조립 및 운영체제 설치를 끝낸 것을 AWS는 단 클릭 몇 번만으로 5분 만에 컴퓨터가 장만 되었고… 한 컴퓨터 안에 데이터베이스, 메일 전송, 데이터 저장 공간을 두는 것이 아니라 개별 서비스로 연결해서 쓸 수 있었던 면에서도 깜짝 놀랐습니다이때부터 저는 AWS를 심도 있게 사용해보고 있으며, 2019년 4월 18일에 있었던 AWS SUMMIT Seoul 컨퍼런스도 다녀오게 되었습니다제 AWS 사용 동기는 아래와 같습니다 저와 같은 사람이 있을 것이라 생각하며, 또 AWS에 이제 관심을 갖기 시작한 사람들에게 제 블로그가 도움이 되었으면 합니다솔직히 말해 AWS에 대해서 깊이 다뤄보지 못했지만 AWS가 이런 것이다에 대해서 이해만 하길 바라며 읽어주시면 감사하겠습니다 AWS는 어디에 위치해있는가? AWS region 참조 관련 이미지Amazon Web Services는 다음 그림과 같이 여러 지역(regions)에 위치해있습니다 다음 그림에 표시된 곳에 엄청난 크기와 양의 컴퓨터가 있고, 우리는 AWS의 멤버(회원)이 되어 컴퓨터를 ‘빌려’ 쓴다고 생각하면 됩니다 다시말해 AWS에서 제공해주는 서비스를 이용해 내가 지금 내 컴퓨터에서 아마존 컴퓨터를 원격으로 사용하는 것 입니다 이 말이 즉 클라우드 컴퓨팅이라고 생각하면 되겠습니다","categories":[{"name":"infra","slug":"infra","permalink":"https://msnodeve.github.io/categories/infra/"},{"name":"aws","slug":"infra/aws","permalink":"https://msnodeve.github.io/categories/infra/aws/"},{"name":"cloud","slug":"infra/aws/cloud","permalink":"https://msnodeve.github.io/categories/infra/aws/cloud/"}],"tags":[{"name":"Infra","slug":"infra","permalink":"https://msnodeve.github.io/tags/infra/"},{"name":"AWS","slug":"aws","permalink":"https://msnodeve.github.io/tags/aws/"},{"name":"Cloud","slug":"cloud","permalink":"https://msnodeve.github.io/tags/cloud/"}]},{"title":"Docker Compose 설치하기","slug":"infra-install-docker-compose","date":"2019-01-08T09:44:36.000Z","updated":"2020-06-25T05:36:17.583Z","comments":true,"path":"2019/01/08/infra-install-docker-compose/","link":"","permalink":"https://msnodeve.github.io/2019/01/08/infra-install-docker-compose/","excerpt":"Docker Compose 설치하기이번 포스트에서는 도커를 설치하는 방법에 대해서 알아 보도록 하겠습니다. 도커 도커컴포즈 Docker Docker Compose","text":"Docker 설치필수 패키지 설치123$ yum install -y yum-utils device-mapper-persistent-data lvm2$ yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo$ yum makecache fast 다운로드1$ yum install docker-ce 실행123$ systemctl start docker$ systemctl enable docker$ docker --version Docker-compose 설치다운로드1$ curl -L https://github.com/infra/docker/compose/releases/download/1.14.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose 권한 부여 및 실행12$ chmod +x /usr/local/bin/docker-compose$ docker-compose --version 수고하셨습니다Docker, Docker Compose 를 설치 했습니다","categories":[{"name":"infra","slug":"infra","permalink":"https://msnodeve.github.io/categories/infra/"},{"name":"docker","slug":"infra/docker","permalink":"https://msnodeve.github.io/categories/infra/docker/"},{"name":"docker compose","slug":"infra/docker/docker-compose","permalink":"https://msnodeve.github.io/categories/infra/docker/docker-compose/"}],"tags":[{"name":"Infra","slug":"infra","permalink":"https://msnodeve.github.io/tags/infra/"},{"name":"Docker","slug":"docker","permalink":"https://msnodeve.github.io/tags/docker/"},{"name":"Docker Compose","slug":"docker-compose","permalink":"https://msnodeve.github.io/tags/docker-compose/"}]},{"title":"Mac에서 멋진 터미널 만들기","slug":"mac-settings","date":"2018-10-23T10:18:19.000Z","updated":"2020-06-28T14:42:24.284Z","comments":true,"path":"2018/10/23/mac-settings/","link":"","permalink":"https://msnodeve.github.io/2018/10/23/mac-settings/","excerpt":"멋진 맥 터미널 만들기!이번 포스트에서는 멋진 맥 개발환경을 만들어 보도록 하겠습니다. 맥 개발환경 만들어보자! 터미널","text":"iTerm2 설치iTerm2 다운로드 페이지에 접속한 뒤, iTerm2 를 설치합니다 HomeBrew 설치 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Zsh 설치1brew install zsh OhMyZsh 설치설치시 mac 잠금 해제 암호를 물어봅니다, 입력해도 * 이 뜨지않으니 그냥 입력 후 엔터하시면 됩니다 1sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" Oceanic Next iTerm 색 테마 입히기 master.zip을 다운로드 후 압축을 해제합니다 iTerm2 &gt; Preferences… &gt; 클릭 합니다 Profile &gt; Default &gt; Colors &gt; Color Presets… &gt; Oceanic-Next &gt; 클릭 후 완료 합니다 Agnoster 테마 설치 명령어 입력후 10번째 줄을 다음과 같이 입력 합니다 12vi ~/.zshrcZSH_THEME=\"agnoster\" Ubuntu Mono derivative Powerline 폰트 설치 &amp; 설정Ubuntu_Mono_derivative_Powerline.ttf를 다운로드 합니다 iTerm2 &gt; Preferences… &gt; 클릭 합니다 Profile &gt; Default &gt; Text &gt; Change Font &gt; Ubuntu Mono derivative &gt; 클릭 후 완료 합니다 zsh-syntax-highlighting 설치아래 두줄을 터미널에 입력합니다 12git clone https://github.com/zsh-users/zsh-syntax-highlighting.gitecho \"source $&#123;(q-)PWD&#125;/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\" &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrc 수고하셨습니다이제 iTerm2를 완전히 종료한 후에 다시 실행하여 멋진 터미널을 이용해 보세요","categories":[{"name":"mac","slug":"mac","permalink":"https://msnodeve.github.io/categories/mac/"},{"name":"settings","slug":"mac/settings","permalink":"https://msnodeve.github.io/categories/mac/settings/"}],"tags":[{"name":"Mac","slug":"mac","permalink":"https://msnodeve.github.io/tags/mac/"},{"name":"Zsh","slug":"zsh","permalink":"https://msnodeve.github.io/tags/zsh/"},{"name":"Homebrew","slug":"homebrew","permalink":"https://msnodeve.github.io/tags/homebrew/"}]}]}