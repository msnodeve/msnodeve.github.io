{"meta":{"title":"msnodevLog","subtitle":"아직 익숙하지 않다면 두번이상 개발하는","description":"대부분의 개발자들 처럼 이것저것 아무거나 다 손대보고 익숙해지는게 최선인 것 같다. 그렇다면 한 번이 아닌 두 번이상 개발을 해보며 익숙해 지는게 공부같다.","author":"Myeong Seok KIM","url":"https://msnodeve.github.io","root":"/"},"pages":[{"title":"about","date":"2020-03-08T05:33:14.000Z","updated":"2020-03-08T05:52:02.708Z","comments":true,"path":"about/index.html","permalink":"https://msnodeve.github.io/about/index.html","excerpt":"","text":"Intro김명석 입니다. Github Contribution CoerfolioCoer 는 제가 지은 별명입니다.대학을 오고 함께 프로젝트를 하는 스스로의 모습을보며 협력하다의 Co와 –하는 사람의 –er를 생각해 만든별명입니다.다양한 분야에 관심이 많고, 넓게 보려고 노력하는개발자 김명석 코어폴리오를 소개합니다."},{"title":"all-archives","date":"2020-03-08T06:06:26.735Z","updated":"2020-03-08T06:06:26.735Z","comments":false,"path":"all-archives/index.html","permalink":"https://msnodeve.github.io/all-archives/index.html","excerpt":"","text":""},{"title":"all-categories","date":"2020-03-08T06:07:24.098Z","updated":"2020-03-08T06:07:24.098Z","comments":false,"path":"all-categories/index.html","permalink":"https://msnodeve.github.io/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2020-03-08T06:07:35.300Z","updated":"2020-03-08T06:07:35.300Z","comments":false,"path":"all-tags/index.html","permalink":"https://msnodeve.github.io/all-tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringBoot Database 활용하기(3) - [Backend Framework]","slug":"springboot-step03-springboot-data","date":"2020-06-21T04:07:45.000Z","updated":"2020-06-21T04:17:27.807Z","comments":true,"path":"2020/06/21/springboot-step03-springboot-data/","link":"","permalink":"https://msnodeve.github.io/2020/06/21/springboot-step03-springboot-data/","excerpt":"세번째 단계 Database 연결 및 활용하기이번 포스트에서는 Database 연결 및 MyBatis 활용에 대해서 알아 보도록 하겠습니다. Database MyBatis SpringBoot MySQL","text":"INDEX Backend SpringBoot 프로젝트 생성 및 실행 해보기(1) Backend SpringBoot REST API 만들기(2) 세번째 단계 Database 연결 및 활용하기 Branch Name예제 브랜치 이름은 다음과 같습니다.step03-springboot-data SpringBoot와 Database 연동을 해보자 API를 사용자에게 지속적으로 제공하기 위해서는 영속적인 저장소가 필요합니다.따라서 RDBMS(Relational Database Management System)에 속하는 제품을 사용합니다. 의존성 제외 설정 src/main/resources 폴더 밑에 application.properties 파일을 생성합니다. application.properties 에 다음 줄을 추가합니다. 1spring.main.web-environment=false build.gradle에 필요한 라이브러리를 추가합니다. 버전을 다시 고쳤습니다. 복붙해주세요. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152plugins &#123; id 'java' id 'org.springframework.boot' version '1.5.8.RELEASE'&#125;ext&#123; springBootVersion='1.5.8.RELEASE'&#125;sourceCompatibility = 1.8targetCompatibility = 1.8sourceSets&#123; main&#123; java &#123; srcDir 'src/main/java' &#125; resources&#123; srcDir 'src/resources' &#125; &#125;&#125;repositories &#123; jcenter()&#125;dependencies &#123; compile 'org.springframework.boot:spring-boot-starter-web' compile \"org.springframework.boot:spring-boot-devtools\" compile 'org.slf4j:slf4j-api:1.7.7' testCompile 'junit:junit:4.12' compile group: 'org.springframework.boot', name: 'spring-boot-starter-hateoas', version: '2.1.5.RELEASE' compile group: 'io.springfox', name: 'springfox-swagger2', version: '2.9.2' compile group: 'io.springfox', name: 'springfox-swagger-ui', version: '2.9.2' compile group: 'org.hsqldb', name: 'hsqldb', version:'2.3.2' compile \"org.springframework.boot:spring-boot-starter-data-jpa:$&#123;springBootVersion&#125;\" compile group: 'org.hibernate', name: 'hibernate-validator', version: '4.2.0.Final' compile group: 'javax.el', name: 'javax.el-api', version: '3.0.0' compile group: 'javax.validation', name: 'validation-api', version: '1.0.0.GA' //capcha compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-imaging', version: '1.1' compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-simplecaptcha', version: '1.1'&#125; 데이터 저장소로는 hsqldb를 사용하며, 이는 소형 관계형 데이터베이스 엔진의 일종으로 JDBC를 지원하고, 라이브러리 추가만으로 사용가능해서 로컬 개발시에 많이 쓰입니다. Database Object Mapping값 매핑 src/main/java/seok/model 패키지 밑에 일반 사용자와 관리자 구분을 하는 UserRole.java Enum 클래스를 하나 생성합니다. 123456package seok.model;public enum UserRole &#123; USER, // 0 ADMIN // 1&#125; UserEntity 클래스를 만들어 보자 src/main/java/seok/model 패키지 밑에 UserEntity.java 클래스를 생성합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package seok.model;import javax.persistence.*;import java.util.Date;@Entitypublic class UserEntity &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String name; private Integer age; private Date created; @Column(name=\"role\") @Enumerated(EnumType.ORDINAL) private UserRole role; @PrePersist public void beforeCreate()&#123; created = new Date(); &#125; public UserEntity() &#123; &#125; public UserEntity(String name, Integer age, UserRole role) &#123; this.name = name; this.age = age; this.role = role; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getCreated() &#123; return created; &#125; public void setCreated(Date created) &#123; this.created = created; &#125; @Override public String toString() &#123; return \"UserEntity&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", age=\" + age + \", created=\" + created + \", role=\" + role + '&#125;'; &#125;&#125; @Entity(데이터베이스 스키마의 내용을 자바 클래스로 표현할 수 있는 대상) 어노테이션을 선언함으로써 엔티티 매니저가 관리해야 할 대상임을 명시합니다. @Enumerated 어노테이션 속성으로 @EnumType을 지정할 때, ORDINAL로 하면 값이 int로 할당 되며 STRING으로 지정하면 ENUM의 이름으로 할당 됩니다. User Repository 인터페이스를 생성하자 src/main/java/seok 패키지 밑에 repository 패키지를 생성 후, UserRepository.java 인터페이스를 생성합니다. 1234567891011package seok.repository;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.repository.query.Param;import org.springframework.stereotype.Repository;import seok.model.UserEntity;@Repositorypublic interface UserRepository extends JpaRepository&lt;UserEntity, Long&gt; &#123; UserEntity findByName(@Param(\"name\") String name);&#125; 필드를 검색하기 위해 다음과 같이 사용할 수 있습니다. 1반환 타입 findBy 필드명(파라미터); 실행 결과 보기 application.properties 에 spring.main.web-environment=false 를 설정해줬기 때문에 웹은 실행되지않고, 종료합니다. Database Server와 연동MySQL 설치MySQL DB 설치하기 각 환경에 맞는 서버를 설치합니다. MySQL WorkBench 도 설치하면 좋을 것 같습니다. Database, Table 생성하기 1create database exam; exam 이라는 데이터베이스를 하나 생성합니다. 12345create table tbl_user( id varchar(40) not null, username varchar(45) not null, password varchar(45) not null); user 정보 테이블을 생성합니다. Database Connection Pool HikariCP 사용하기build.gradle 라이브러리 추가합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253plugins &#123; id 'java' id 'idea' id 'org.springframework.boot' version '1.5.8.RELEASE'&#125;ext&#123; springBootVersion='1.5.8.RELEASE'&#125;sourceCompatibility = 1.8targetCompatibility = 1.8sourceSets&#123; main&#123; java &#123; srcDir 'src/main/java' &#125; resources&#123; srcDir 'src/resources' &#125; &#125;&#125;repositories &#123; jcenter()&#125;dependencies &#123; compile 'org.springframework.boot:spring-boot-starter-web' compile \"org.springframework.boot:spring-boot-devtools\" compile 'org.slf4j:slf4j-api:1.7.7' testCompile 'junit:junit:4.12' compile group: 'org.springframework.boot', name: 'spring-boot-starter-hateoas', version: '2.1.5.RELEASE' compile group: 'io.springfox', name: 'springfox-swagger2', version: '2.9.2' compile group: 'io.springfox', name: 'springfox-swagger-ui', version: '2.9.2' compile group: 'org.springframework.boot', name: 'spring-boot-starter-jdbc', version: '2.3.0.RELEASE' compile group: 'com.zaxxer', name: 'HikariCP', version: '2.5.1' compile group: 'org.mybatis.spring.boot', name: 'mybatis-spring-boot-starter', version: '1.3.0' compile group: 'mysql', name: 'mysql-connector-java', version: '8.0.13' //capcha compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-imaging', version: '1.1' compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-simplecaptcha', version: '1.1'&#125; application.properties 에 MySQL DB 서버 정보를 설정합니다. 123456spring.datasource.driverClassName=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://127.0.0.1:3306/exam?serverTimezone=UTC&amp;useUniCode=yes&amp;characterEncoding=UTF-8spring.datasource.username=ssafyspring.datasource.password=ssafymybatis.config-location=classpath:mybatis-config.xml Mybitis와 MySQL 연동 src/main/resources 아래 다음 파일을 생성합니다. 123456789&lt;!-- mybatis-config.xml --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;mappers&gt; &lt;mapper resource=\"mappers/userMapper.xml\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; 12345678910111213141516171819202122232425262728293031323334&lt;!-- userMapper.xml --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"user\"&gt; &lt;insert id=\"insertUser\"&gt; insert into tbl_user(id, username, password) value (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;) &lt;/insert&gt; &lt;select id=\"selectAll\" resultType=\"seok.model.User\"&gt; select id, username, password from tbl_user &lt;/select&gt; &lt;select id=\"select\" resultType=\"seok.model.User\"&gt; select id, username, password from tbl_user where id = #&#123;id&#125; &lt;/select&gt; &lt;update id=\"update\"&gt; update tbl_user set username = #&#123;username&#125;, password = #&#123;password&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;delete id=\"delete\"&gt; delete from tbl_user where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; MVC 패턴으로 패키지 구성하기 위 그림과 같이 파일을 구성 합니다. 1234567891011121314151617package seok.repository;import seok.model.User;import java.util.List;public interface UserRepository &#123; public List&lt;User&gt; selectAll() throws Exception; public User select(String id) throws Exception; public int insert(User user) throws Exception; public int update(User user) throws Exception; public int delete(String id) throws Exception;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041package seok.repository;import org.apache.ibatis.session.SqlSession;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Repository;import seok.model.User;import java.util.List;@Repositorypublic class UserRepositoryImpl implements UserRepository &#123; private static final String MAPPER_NAME_SPACE = \"user.\"; @Autowired SqlSession sqlSession; @Override public List&lt;User&gt; selectAll() throws Exception &#123; return sqlSession.selectList(MAPPER_NAME_SPACE + \"selectAll\"); &#125; @Override public User select(String id) throws Exception &#123; return sqlSession.selectOne(MAPPER_NAME_SPACE + \"select\", id); &#125; @Override public int insert(User user) throws Exception &#123; return sqlSession.insert(MAPPER_NAME_SPACE + \"insertUser\", user); &#125; @Override public int update(User user) throws Exception &#123; return sqlSession.update(MAPPER_NAME_SPACE + \"update\", user); &#125; @Override public int delete(String id) throws Exception &#123; return sqlSession.delete(MAPPER_NAME_SPACE + \"delete\", id); &#125;&#125; 1234567891011121314151617package seok.service;import seok.model.User;import java.util.List;public interface UserService &#123; public List&lt;User&gt; findAllUsers() throws Exception; public User findByUserId(String id) throws Exception; public int registry(User user) throws Exception; public int modify(User user) throws Exception; public int remove(String id) throws Exception;&#125; 123456789101112131415161718192021222324252627282930313233343536373839package seok.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import seok.model.User;import seok.repository.UserRepository;import java.util.List;@Servicepublic class UserServiceImpl implements UserService&#123; @Autowired UserRepository repository; @Override public List&lt;User&gt; findAllUsers() throws Exception &#123; return repository.selectAll(); &#125; @Override public User findByUserId(String id) throws Exception &#123; return repository.select(id); &#125; @Override public int registry(User user) throws Exception &#123; return repository.insert(user); &#125; @Override public int modify(User user) throws Exception &#123; return repository.update(user); &#125; @Override public int remove(String id) throws Exception &#123; return repository.delete(id); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package seok.controller;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;import seok.model.User;import seok.service.UserService;import java.util.List;@RestController@RequestMapping(value = \"/api\")@Api(value=\"msnodeve\")public class UserController &#123; @Autowired UserService service; @GetMapping(\"/user\") @ApiOperation(value = \"모든 유저의 정보를 반환한다.\", response = List.class) public ResponseEntity&lt;List&lt;User&gt;&gt; findAllUsers() &#123; List&lt;User&gt; users = null; try &#123; users = service.findAllUsers(); &#125; catch (Exception e) &#123; e.printStackTrace(); return new ResponseEntity&lt;&gt;(null, HttpStatus.NO_CONTENT); &#125; return new ResponseEntity&lt;&gt;(users, HttpStatus.OK); &#125; @GetMapping(\"/user/&#123;id&#125;\") @ApiOperation(value = \"유저의 정보를 반환한다.\", response = Object.class) public ResponseEntity&lt;User&gt; findByUserId(@PathVariable String id) &#123; User user = null; try &#123; user = service.findByUserId(id); &#125; catch (Exception e) &#123; e.printStackTrace(); return new ResponseEntity&lt;&gt;(null, HttpStatus.NO_CONTENT); &#125; return new ResponseEntity&lt;&gt;(user, HttpStatus.OK); &#125; @PostMapping(\"/user\") @ApiOperation(value = \"유저의 정보를 입력한다.\", response = String.class) public ResponseEntity&lt;String&gt; registryUser(@RequestBody User user) &#123; try &#123; if (service.registry(user) != 0) return new ResponseEntity&lt;&gt;(\"성공적으로 등록되었습니다.\", HttpStatus.CREATED); else return new ResponseEntity&lt;&gt;(\"등록 실패했습니다.\", HttpStatus.BAD_REQUEST); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return new ResponseEntity&lt;&gt;(\"등록 실패했습니다.\", HttpStatus.BAD_REQUEST); &#125; @PutMapping(\"/user\") @ApiOperation(value = \"유저의 정보를 수정한다.\", response = String.class) public ResponseEntity&lt;String&gt; modifyUser(@RequestBody User user) &#123; try &#123; if (service.modify(user) != 0) return new ResponseEntity&lt;&gt;(\"성공적으로 수정되었습니다.\", HttpStatus.OK); else return new ResponseEntity&lt;&gt;(\"수정 실패했습니다.\", HttpStatus.BAD_REQUEST); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return new ResponseEntity&lt;&gt;(\"수정 실패했습니다.\", HttpStatus.BAD_REQUEST); &#125; @DeleteMapping(\"/user/&#123;id&#125;\") @ApiOperation(value = \"유저의 정보를 삭제한다.\", response = String.class) public ResponseEntity&lt;String&gt; removeUser(@PathVariable String id) &#123; try &#123; if (service.remove(id) != 0) return new ResponseEntity&lt;&gt;(\"성공적으로 삭제되었습니다.\", HttpStatus.OK); else return new ResponseEntity&lt;&gt;(\"삭제 실패했습니다.\", HttpStatus.BAD_REQUEST); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return new ResponseEntity&lt;&gt;(\"삭제 실패했습니다.\", HttpStatus.BAD_REQUEST); &#125;&#125; 실행해보기 등록하기 DB 결과 INDEX Backend SpringBoot 프로젝트 생성 및 실행 해보기(1) Backend SpringBoot REST API 만들기(2)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"spring","slug":"backend/framework/spring","permalink":"https://msnodeve.github.io/categories/backend/framework/spring/"},{"name":"springboot","slug":"backend/framework/spring/springboot","permalink":"https://msnodeve.github.io/categories/backend/framework/spring/springboot/"},{"name":"database","slug":"backend/framework/spring/springboot/database","permalink":"https://msnodeve.github.io/categories/backend/framework/spring/springboot/database/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Spring","slug":"spring","permalink":"https://msnodeve.github.io/tags/spring/"},{"name":"SpringBoot","slug":"springboot","permalink":"https://msnodeve.github.io/tags/springboot/"},{"name":"Database","slug":"database","permalink":"https://msnodeve.github.io/tags/database/"}]},{"title":"SpringBoot REST API 만들기(2) - [Backend Framework]","slug":"springboot-step02-make-rest-api","date":"2020-06-20T10:03:02.000Z","updated":"2020-06-22T01:50:51.596Z","comments":true,"path":"2020/06/20/springboot-step02-make-rest-api/","link":"","permalink":"https://msnodeve.github.io/2020/06/20/springboot-step02-make-rest-api/","excerpt":"두번째 단계 REST API 만들기이번 포스트에서는 REST API를 만드는 방법을 알아 보도록 하겠습니다. 스프링부트 SpringBoot IntelliJ Framework REST API","text":"INDEX Backend SpringBoot 프로젝트 생성 및 실행 해보기(1) Backend SpringBoot Database 활용하기(3) 두번째 단계 Make REST API Branch Name예제 브랜치 이름은 다음과 같습니다.step02-make-rest-api REST의 특성 클라이언트/서버 클라이언트와 서버가 서로 독립적으로 구분 되어야 한다. 또한 서버 또는 클라이언트 증설 시 서로간의 의존성 때문에 확장에 문제가 되서는 안된다. 상태 없음 서버는 클라이언트의 상태를 기억할 필요가 없다. 레이어드 아키텍처 다계층 형태로 레이어를 추가하거나 수정, 제거 할 수 있고 확장성이 있어야한다. 캐시 클라이언트가 캐시를 통해서 응답을 재사용 하여 이를 통해 서버의 부하를 낮춰 서버의 성능이 향상 될 수 있다. 코드 온 디멘드 요청이 오면 코드를 준다. REST 인터페이스 규칙 리소스 식별 웹 안에서 URI와 같은 고유 식별자를 통해 표현한다. 표현을 통한 리소스 처리 JSON, XML, HTML 페이지와 같이 다양한 유형으로 표현 할 수 있다. 자기 묘사 메세지 HTTP 통신 할 때 Http header에 메타 데이터 정보를 추가해서 실제 데이터와는 관련 없지만 데이터에 대한 설명을 나타내는 정보를 담을 수 있다. 애플리케이션 상태 하이퍼미디어(HATEOAS) REST API를 개발할 때도 단순히 데이터만 전달하는 것이 아닌 링크 정보까지 포함한다. REST API 만들기모델 클래스 만들기데이터를 담을 수 있는 클래스를 만듭니다. src/main/java/seok/model 경로를 만들고, 그 밑에 Todo.java 를 생성 Todo.java 내용은 다음과 같습니다. 123456789101112131415161718192021222324252627package seok.model;public class Todo &#123; private int id; private String title; public Todo(int id, String title) &#123; this.id = id; this.title = title; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125;&#125; 컨트롤러 클래스 만들기URL을 요청하면 Todo 클래스의 인스턴스를 생성해 JSON으로 보여줄 수 있는 컨트롤러를 만듭니다. src/main/java/seok/controller 경로 밑에 TodoController.java 를 생성 TodoController.java 내용은 다음과 같습니다. 123456789101112131415161718package seok.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import seok.model.Todo;import java.util.concurrent.atomic.AtomicInteger;@RestController@RequestMapping(value = \"/todo\")public class TodoController &#123; private final AtomicInteger counter = new AtomicInteger(); @RequestMapping(\"/todo\") public Todo todo()&#123; return new Todo(counter.incrementAndGet(), \"코딩하기\"); &#125;&#125; AtomicInteger는 Atomic(더 이상 쪼개질 수 없는 성질)을 의미하며, 단순히 Integer 타입으로 선언한다면 서로 다른 Thread 에서 하나의 변수에 대해 값을 쓰거나 읽기 때문에 문제가 발생할 수 있지만, AtomicInteger를 쓰므로 Thread-safe 하게 처리가 가능합니다. 실행해보기localhost:8080/todo/todo 를 계속 호출해보면 호출 할 때마다 숫자가 정상적으로 증가하는 것을 확인 할 수 있습니다. REST API에서 HTTP Method 사용컨트롤러 메서드에 POST 매핑TodoController.java 에 POST 메서드를 만듭니다. 1234@PostMapping(\"/todo\")public Todo registryTodo(@RequestParam(value=\"todoTitle\") String todoTitle)&#123; return new Todo(counter.incrementAndGet(), todoTitle);&#125; /todo/todo를 엔드 포인트로 합니다. GET은 Body 가 없어서 URL을 직접 호출 할 수 있지만, POST는 요청의 몸체가 되므로 도구를 사용해서 테스트 해봐야합니다. 여기서는 Postman를 사용하도록 하겠습니다. Postman 설치하기 위와 같이 실행하면 결과값을 받아 볼 수 있습니다. 응답 헤더 활용하기ResponseEntity 클래스는 HttpEntity를 상속받은 클래스로 Http 응답에 대한 상태값을 표현 할 수 있습니다. TodoController.java 에 다음 코드를 추가합니다. 1234@PostMapping(\"/todo/response\")public ResponseEntity&lt;Todo&gt; postRegistryTodo(@RequestParam String todoTitle)&#123; return new ResponseEntity&lt;&gt;(new Todo(counter.incrementAndGet(), todoTitle), HttpStatus.CREATED);&#125; 결과를 받아보면 Status: 201 Created 라는 결과를 받아 볼 수 있습니다. HATEOAS를 사용한 URI 정보 표현하기HATEOAS 설정build.gradle 파일에 다음 라이브러리를 추가합니다. 123dependencies &#123; compile 'org.springframework.boot:spring-boot-starter-hateoas'&#125; ResourceSupport 클래스를 상속받을 모델 클래스 TodoResource.java를 만들도록 하겠습니다. 1234567891011121314151617181920212223package seok.model;import org.springframework.hateoas.ResourceSupport;public class TodoResource extends ResourceSupport &#123; private String title; public TodoResource() &#123; &#125; public TodoResource(String title) &#123; this.title = title; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125;&#125; Controller에 다음을 추가하도록 하겠습니다. 1234567891011import static org.springframework.hateoas.mvc.ControllerLinkBuilder.linkTo;import static org.springframework.hateoas.mvc.ControllerLinkBuilder.methodOn;...@PostMapping(\"/todo/hateoas\")public ResponseEntity&lt;TodoResource&gt; resourceResponseEntity(@RequestParam String todoTitle)&#123; TodoResource todoResource = new TodoResource(todoTitle); todoResource.add(linkTo(methodOn(TodoController.class).resourceResponseEntity(todoTitle)).withSelfRel()); return new ResponseEntity&lt;&gt;(todoResource, HttpStatus.OK);&#125; todoResource 인스턴스를 생성한 후에 링크 정보 추가를 위해서 linkTo 메서드로 TodoController 클래스의 resourceResponseEntity 메서드를 매핑후, withSelfRel 메서드를 이용해 URL 정보를 만들고 add메서드로 정보를 추가했습니다. 결과는 다음과 같습니다. REST API 문서화 API를 제공하려면 가이드 문서 제공이 필수적인데, 개발할 때 마다 별도의 문서를 작성하고 업데이트하는 것은 비용이 많이 듭니다. 따라서 Swagger 를 이용해서 API를 설명하는 페이지를 자동 생성하는 방법을 알아 보도록 하겠습니다. Swagger 라이브러리 추가build.gradle에 springfox-swagger2, springfox-swagger-ui을 추가합니다. dependencies의 라이브러리들을 최신, 가장많이 사용하는 라이브러리들로 좀 교체했습니다.build.gradle의 전체 내용은 다음과 같습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344plugins &#123; id 'java' id 'org.springframework.boot' version '2.2.2.RELEASE'&#125;ext&#123; springBootVersion='2.2.2.RELEASE'&#125;sourceCompatibility = 1.8targetCompatibility = 1.8sourceSets&#123; main&#123; java &#123; srcDir 'src/main/java' &#125; resources&#123; srcDir 'src/resources' &#125; &#125;&#125;repositories &#123; jcenter()&#125;dependencies &#123; compile group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '2.2.2.RELEASE' compile group: 'org.springframework.boot', name: 'spring-boot-devtools', version: '2.0.4.RELEASE' compile group: 'org.springframework.boot', name: 'spring-boot-starter-hateoas', version: '2.1.5.RELEASE' compile group: 'io.springfox', name: 'springfox-swagger2', version: '2.9.2' compile group: 'io.springfox', name: 'springfox-swagger-ui', version: '2.9.2' compile 'org.slf4j:slf4j-api:1.7.7' testCompile 'junit:junit:4.12' //capcha compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-imaging', version: '1.1' compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-simplecaptcha', version: '1.1'&#125; SwaggerConfiguration 클래스 만들기 src/main/java/seok/configuration 패키지 생성 후 SwaggerConfiguration.java 클래스를 생성합니다. 12345678910111213141516171819202122232425262728293031323334package seok.configuration;import com.google.common.base.Predicate;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;import static com.google.common.base.Predicates.or;import static springfox.documentation.builders.PathSelectors.regex;@Configuration@EnableSwagger2public class SwaggerConfiguration &#123; @Bean public Docket postsApi() &#123; return new Docket(DocumentationType.SWAGGER_2).groupName(\"public-api\") .apiInfo(apiInfo()).select().paths(postPaths()).build(); &#125; private Predicate&lt;String&gt; postPaths() &#123; return or(regex(\"/todo/.*\")); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder().title(\"TODO API\") .description(\"Todo REST API 개발 문서\") .license(\"msnodeve License\") .licenseUrl(\"msnodeve@gmail.com\").version(\"1.0\").build(); &#125;&#125; 123private Predicate&lt;String&gt; postPaths() &#123; return or(regex(\"/todo/.*\"));&#125; 해당 부분은 컨트롤러의 기본 URI 가 todo로 시작하기 때문에 /todo만 인식하도록 설정을 추가한 것 입니다. 실행해보기http://localhost:8080/swagger-ui.html#/ 로 접속을 해보면 지금까지 작성해온 API가 UI로 표시되는 모습을 확인 할 수 있습니다. 각 메서드의 별도 동작은 한번씩 작동 시켜보길 바랍니다. INDEX Backend SpringBoot 프로젝트 생성 및 실행 해보기(1) Backend SpringBoot Database 활용하기(3)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"spring","slug":"backend/framework/spring","permalink":"https://msnodeve.github.io/categories/backend/framework/spring/"},{"name":"springboot","slug":"backend/framework/spring/springboot","permalink":"https://msnodeve.github.io/categories/backend/framework/spring/springboot/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Spring","slug":"spring","permalink":"https://msnodeve.github.io/tags/spring/"},{"name":"SpringBoot","slug":"springboot","permalink":"https://msnodeve.github.io/tags/springboot/"}]},{"title":"SpringBoot 프로젝트 생성 및 실행 해보기(1) - [Backend Framework]","slug":"springboot-stop01-create-project-run","date":"2020-06-10T12:07:48.000Z","updated":"2020-06-22T01:50:39.991Z","comments":true,"path":"2020/06/10/springboot-stop01-create-project-run/","link":"","permalink":"https://msnodeve.github.io/2020/06/10/springboot-stop01-create-project-run/","excerpt":"첫번째 단계 프로젝트 생성하기이번 포스트에서는 IntelliJ 개발환경에서 SpringBoot Framework 프로젝트를 생성하고 실행해보는 시간을 가져 보도록 하겠습니다. 스프링부트 SpringBoot IntelliJ Framework 프로젝트 생성하는 방법!","text":"INDEX Backend SpringBoot REST API 만들기(2) Backend SpringBoot Database 활용하기(3) 첫번째 단계 Make Project Branch Name예제 브랜치 이름은 다음과 같습니다.step01-make-project 1. IntelliJ로 Spring Boot 프로젝트 만들기 file → New → Project 를 클릭해서 새로운 프로젝트를 생성 New Project의 유형 중에서 Gradle을 선택하고 Next 버튼을 클릭 프로젝트 이름과 프로젝트가 저장될 로컬 디렉터리, 패키지명 지정 Ok, apply suggestion! 을 클릭 2. Spring Boot에 대한 이해자바 기반에서 개발을 진행할 때 결과 파일 포맷은 크게 두 가지로 구분하며 로컬에서 실행되는 JAR, 웹 애플리케이션 컨테이너에서 실행되는 WAR입니다. Spring Boot에서 웹 자원들을 실행하기 위한 규약 위와 같이 폴더를 생성 웹 자원들을 각 규약에 맞는 곳에 두면 웹을 위한 별도의 폴더를 만들지 않고 사용이 가능합니다. Gradle을 이용한 Spring Boot 설정build.gradle 파일에서 Spring Boot 플러그인을 사용 할 수 있도록 설정하는데, 여기서 의존성을 추가하도록 합니다. build.gradle 파일의 전체 내용은 다음과 같습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546plugins &#123; id 'java' id 'org.springframework.boot' version '1.5.8.RELEASE'&#125;ext&#123; springBootVersion='1.5.8.RELEASE'&#125;sourceCompatibility = 1.8targetCompatibility = 1.8sourceSets&#123; main&#123; java &#123; srcDir 'src/main/java' &#125; resources&#123; srcDir 'src/resources' &#125; &#125;&#125;repositories &#123; jcenter()&#125;dependencies &#123; compile 'org.springframework.boot:spring-boot-starter-web' compile \"org.springframework.boot:spring-boot-starter-thymeleaf\" compile \"org.springframework.boot:spring-boot-devtools\" compile group: 'org.webjars', name: 'webjars-locator', version: '0.32' compile 'org.webjars:jquery:3.1.0' compile 'org.webjars:bootstrap:3.3.1' compile 'org.webjars:materializecss:0.96.0' compile 'org.slf4j:slf4j-api:1.7.7' testCompile 'junit:junit:4.12' //capcha compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-imaging', version: '1.1' compile group: 'com.google.code.maven-play-plugin.org.playframework', name: 'jj-simplecaptcha', version: '1.1'&#125; Controller 만들기 src/main/java/seok/controller 경로를 만들고, 그 밑에 HomeController.java 를 생성 HomeController.java의 전체는 다음과 같습니다. 123456789101112package seok.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HomeController &#123; @RequestMapping(\"/\") public String hello() &#123; return \"hello\"; &#125;&#125; 배포 시에 root-context를 / 로 설정할 것이므로 http://localhost:8080 을 입력 했을 때 hello 가 출력되도록 합니다. Controller를 사용하는 Main 클래스 만들기 src/main/java/seok 경로 아래에 Main 클래스를 생성 SpringBootApiMainApplication.java 의 전체 내용은 다음과 같습니다. 1234567891011package seok;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringBootApiMainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootApiMainApplication.class, args); &#125;&#125; @SpringBootApplication 어노테이션의 역할 @ComponentScan(basePadkages = “seok.controller”) @Configuration @EnableAutoConfiguration 의 세 가지 어노테이션을 @SpringBootApplication 어노테이션으로 대체 할 수 있습니다. 실행하는 방법 2가지 SpringBootApiMainApplication.java 를 우클릭 하고 Run Terminal 탭을 열어 ./gradlew bootRun 명령어 실행 (참고로 해당 terminal은 git bash로 실행 중) 실행하게 되면 다음과 같은 로그를 볼 수 있습니다. 1234567891011121314151617181920212223오후 7:01:11: Executing task &#39;SpringBootApiMainApplication.main()&#39;...&gt; Task :compileJava UP-TO-DATE&gt; Task :processResources NO-SOURCE&gt; Task :classes UP-TO-DATE&gt; Task :SpringBootApiMainApplication.main()... . ____ _ __ _ _ &#x2F;\\\\ &#x2F; ___&#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &#39;_ | &#39;_| | &#39;_ \\&#x2F; _&#96; | \\ \\ \\ \\ \\\\&#x2F; ___)| |_)| | | | | || (_| | ) ) ) ) &#39; |____| .__|_| |_|_| |_\\__, | &#x2F; &#x2F; &#x2F; &#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|_|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|___&#x2F;&#x3D;&#x2F;_&#x2F;_&#x2F;_&#x2F; :: Spring Boot :: (v1.5.8.RELEASE)...2020-06-06 19:01:17.135 INFO 18752 --- [ restartedMain] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2020-06-06 19:01:17.203 INFO 18752 --- [ restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2020-06-06 19:01:17.208 INFO 18752 --- [ restartedMain] seok.SpringBootApiMainApplication : Started SpringBootApiMainApplication in 3.963 seconds (JVM running for 4.709) 이제 브라우저를 열어 localhost:8080 을 입력해봅니다. INDEX Backend SpringBoot REST API 만들기(2) Backend SpringBoot Database 활용하기(3)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"spring","slug":"backend/framework/spring","permalink":"https://msnodeve.github.io/categories/backend/framework/spring/"},{"name":"springboot","slug":"backend/framework/spring/springboot","permalink":"https://msnodeve.github.io/categories/backend/framework/spring/springboot/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Spring","slug":"spring","permalink":"https://msnodeve.github.io/tags/spring/"},{"name":"SpringBoot","slug":"springboot","permalink":"https://msnodeve.github.io/tags/springboot/"}]},{"title":"LIS(최장 증가 수열) - [Algorithm Skill]","slug":"algorithm-lis","date":"2020-05-24T03:36:30.000Z","updated":"2020-05-24T08:04:24.158Z","comments":true,"path":"2020/05/24/algorithm-lis/","link":"","permalink":"https://msnodeve.github.io/2020/05/24/algorithm-lis/","excerpt":"알고리즘의 기본적인 스킬을 다룹니다.이번 포스트에서는 알고리즘의 스킬 중 LIS(최장 증가 수열)에 대해서 알아 보려고 합니다. DP 보다 효율적인 탐색 방법 Binary Search","text":"알고리즘의 기본적인 스킬을 다룹니다.이번 포스트에서는 알고리즘의 스킬 중 LIS(최장 증가 수열)에 대해서 알아 보려고 합니다.목차는 다음과 같습니다. 1. 최장 증가 수열이란?2. 최장 증가 수열의 경로는?3. 이진탐색을 통해 최장 증가 수열 찾기4. 이진탐색을 통해 최장 증가 수열의 경로는? LIS LIS란 Longest Increasing Subsequence 최장 증가 수열이라고 말하며, 이는 어떤 수열이 나열 되어있을때, 그 배열의 순서를 유지하며 크기가 점차 커지는 가장 긴 부분수열의 길이가 몇인지를 구하는 알고리즘이라고 할 수 있습니다. 무슨 말인지 예를 들어서 한번 보도록 하겠습니다. 3, 2, 6, 4, 5, 1위와 같은 수열이 있다고 가정하겠습니다. 이때 최장 증가 수열은 무엇일까요? 왼쪽에서 오른쪽으로 확인해보며 봤을 경우,3, 4, 5 또는 2, 4, 5 가 점차적으로 증가하며 부분 수열인 것을 확인 할 수 있습니다. 그럼 이 부분 수열을 과연 어떻게 구할 수 있을까요? 한번 코드로 확인해보도록 하겠습니다. 12345678910111213141516171819202122232425262728import java.util.Arrays;public class LIS_DP &#123; public static void main(String[] args) &#123; int[] list = &#123;3, 2, 6, 4, 5, 1&#125;; int[] LIS = new int[list.length]; // i 번째 숫자를 마지막 숫자로 사용할 경우 최장 증가 수열의 길이를 저장할 배열 for (int i = 0; i &lt; LIS.length; i++) &#123; LIS[i] = 1; for (int j = 0; j &lt; i; j++) &#123; if (list[j] &lt; list[i] &amp;&amp; LIS[i] &lt; LIS[j] + 1)&#123; LIS[i] = LIS[j] + 1; &#125; &#125; &#125; System.out.println(Arrays.toString(LIS)); // 최대 값을 찾기 int maxLISIndex = 0; for (int i = 0; i &lt; LIS.length; i++) &#123; if(LIS[maxLISIndex] &lt; LIS[i])&#123; maxLISIndex = i; &#125; &#125; System.out.println(\"최장 증가 수열의 길이 : \" + LIS[maxLISIndex]); &#125;&#125; 핵심코드는 이 부분 입니다.12345678910for (int i = 0; i &lt; LIS.length; i++) &#123; LIS[i] = 1; // 모든 배열을 값을 1로 초기화 for (int j = 0; j &lt; i; j++) &#123; // 내 앞의 숫자 중에 작은 숫자들을 찾기 if (list[j] &lt; list[i] &amp;&amp; LIS[i] &lt; LIS[j] + 1)&#123; // 나를 기준으로 내앞의 원소가 작으며, // 내가 들고있는 최장 증가 수열의 길이보다 그 값(+1)을 넣은 값이 크다면 LIS[i] = LIS[j] + 1; &#125; &#125;&#125; 이 코드를 해석하자면 다음과 같이 나타 낼 수 있습니다. 주어진 수열{ 3, 2, 6, 4, 5 ,1 } LIS(1) LIS(2) LIS(3) LIS(4) LIS(5) LIS(6) 1 1 2 2 3 1 {3} {2} {3, 6} {3, 4} {3, 4, 5} {1} {3} {2} {2, 6} {2, 4} {2, 4, 5} {1} 따라서 최장 증가 수열의 제일 긴 길이는 LIS(5)의 3이라고 볼 수 있습니다. 경로 구하기 그렇다면 그 최장 증가 수열에서의 경로는 어떻게 구할까요? 코드를 한번 보도록 하겠습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.Arrays;public class LIS_DP_Path &#123; public static void main(String[] args) &#123; int[] list = &#123;3, 2, 6, 4, 5, 1&#125;; int[] LIS = new int[list.length]; // i 번째 숫자를 마지막 숫자로 사용할 경우 최장 증가 수열의 길이를 저장할 배열 int[] path = new int[list.length]; // 경로를 역추적 할 배열 for (int i = 0; i &lt; LIS.length; i++) &#123; LIS[i] = 1; // 모든 배열을 값을 1로 초기화 path[i] = -1; // 내 앞의 수열 숫자의 index for (int j = 0; j &lt; i; j++) &#123; // 내 앞의 숫자 중에 작은 숫자들을 찾기 if (list[j] &lt; list[i] &amp;&amp; LIS[i] &lt; LIS[j] + 1) &#123; // 나를 기준으로 내앞의 원소가 작으며, // 내가 들고있는 최장 증가 수열의 길이보다 그 값(+1)을 넣은 값이 크다면 LIS[i] = LIS[j] + 1; path[i] = j; // 내 앞 수열을 찾았기 때문에 그 index 저장 &#125; &#125; &#125; System.out.println(\"LIS : \" + Arrays.toString(LIS)); // 최대 값을 찾기 int maxLISIndex = 0; for (int i = 0; i &lt; LIS.length; i++) &#123; if (LIS[maxLISIndex] &lt; LIS[i]) &#123; maxLISIndex = i; &#125; &#125; System.out.println(\"최장 증가 수열의 길이 : \" + LIS[maxLISIndex]); System.out.println(\"Path : \" + Arrays.toString(path)); StringBuilder lisPath = new StringBuilder(); for (int i = maxLISIndex; i != -1; i = path[i]) &#123; // 최장 증가 수열의 index번호를 기준으로 앞으로 이동하며 -1을 만날 때 까지 출력 lisPath.insert(0, list[i] + \" \"); // 제일 처음으로 삽입 &#125; System.out.println(lisPath.toString()); &#125;&#125; 이 코드의 기본 원리는 내 앞의 수열 Index를 저장하며 마지막에 역추적한다.에 의미를 두고 있습니다. 12345678910for (int i = 0; i &lt; LIS.length; i++) &#123; ... path[i] = -1; // 내 앞의 수열 숫자의 index for (int j = 0; j &lt; i; j++) &#123; // 내 앞의 숫자 중에 작은 숫자들을 찾기 if (list[j] &lt; list[i] &amp;&amp; LIS[i] &lt; LIS[j] + 1) &#123; ... path[i] = j; // 내 앞 수열을 찾았기 때문에 그 index 저장 &#125; &#125;&#125; 내 앞의 숫자를 탐색하며 작은 숫자를 찾을 때 조금의 코드를 추가해주면서 작성할 수 있습니다.path[i] = j;를 작성해주며 경로를 작성 할 수 있으며,결과값을 보도록 하겠습니다. 1234LIS : [1, 1, 2, 2, 3, 1]최장 증가 수열의 길이 : 3Path : [-1, -1, 0, 0, 3, -1]3 4 5 3, 4, 5가 나왔지만, 2, 4, 5 도 됩니다. 프로그램 상 앞으로 현재값을 기준으로 찾기 때문입니다. 좋습니다. 이렇게 최장 증가 수열에 대해서 알아봤지만, 이 알고리즘의 경우 O(n^2)의 시간 복잡도를 갖고 있습니다. i를 n번 돌리며 j가 0부터 i까지 확인 하기 때문에. 좀 더 씬빡 한방법을 생각해보도록 하겠습니다. Binary Search를 통해 LIS 찾기Binary Search로 LIS를 어떻게 찾는지 예시를 통해 확인해보도록 하겠습니다. 8, 2, 4, 3, 6, 11, 7, 10, 14, 5 라는 수열이 있다고 가정해 보겠습니다. LIS List는 LIS로 사용가능한 숫자를 저장하는 List라고 하겠으며,LIS[i]는 가장 작은 값을 LIS[i]에 저장한다고 하겠습니다. 8 2 4 3 6 11 7 10 14 5 8 2 2 2 2 2 2 2 2 2 4 3 3 3 3 3 3 3 6 6 6 6 6 5 11 7 7 7 7 10 10 10 14 14 진행 순서는 다음과 같습니다. 123456789101 : 8을 LIS에 넣음2 : 2를 LIS 이진 탐색을 통해 넣을 위치를 확인(2보다 작은 값 찾지 못함) -&gt; -1을 리턴하며 0번째에 입력3 : 4를 LIS 이진 탐색을 통해 넣을 위치를 확인(4보다 작은 값 2 위치를 -부호로) -&gt; -2를 리턴하며 1번째에 입력4 : 3를 LIS 이진 탐색을 통해 넣을 위치를 확인(3보다 작은 값 2 위치를 -부호로) -&gt; -2를 리턴하며 1번째에 입력4 : 6를 LIS 이진 탐색을 통해 넣을 위치를 확인(6보다 작은 값 3 위치를 -부호로) -&gt; -3를 리턴하며 2번째에 입력5 : 11를 LIS 이진 탐색을 통해 넣을 위치를 확인(11보다 작은 값 6 위치를 -부호로) -&gt; -4를 리턴하며 3번째에 입력6 : 7를 LIS 이진 탐색을 통해 넣을 위치를 확인(7보다 작은 값 6 위치를 -부호로) -&gt; -4를 리턴하며 3번째에 입력7 : 10를 LIS 이진 탐색을 통해 넣을 위치를 확인(10보다 작은 값 7 위치를 -부호로) -&gt; -5를 리턴하며 4번째에 입력8 : 14를 LIS 이진 탐색을 통해 넣을 위치를 확인(14보다 작은 값 10 위치를 -부호로) -&gt; -6를 리턴하며 5번째에 입력9 : 5를 LIS 이진 탐색을 통해 넣을 위치를 확인(5보다 작은 값 3 위치를 -부호로) -&gt; -3를 리턴하며 2번째에 입력 이렇게 최장 증가 수열을 구할 수 있게 됩니다. 그럼 코드로 한번 작성해 보도록 하겠습니다. 12345678910111213141516171819202122import java.util.Arrays;public class LIS_Binary &#123; public static void main(String[] args) &#123; int[] list = &#123;8, 2, 4, 3, 6, 11, 7, 10, 14, 5&#125;; int[] LIS = new int[list.length]; // LIS로 사용가능한 숫자를 저장 int size = 0; // LIS의 개수를 관리할 변수 LIS[size++] = list[0]; // 첫번째 숫자는 바로 반영 for (int i = 1; i &lt; list.length; i++) &#123; if(LIS[size-1] &lt; list[i])&#123; LIS[size++] = list[i]; // 제일 뒤에 붙이기 &#125;else&#123; int temp = Arrays.binarySearch(LIS,0, size, list[i]); // 삽입할 위치 if(temp &lt; 0) temp = -temp -1; LIS[temp] = list[i]; &#125; &#125; System.out.println(\"LIS : \" + Arrays.toString(LIS)); System.out.println(\"LIS의 개수 : \" + size); &#125;&#125; 이 코드에서 가장 중요한 부분은 이 부분 입니다. 123if(LIS[size-1] &lt; list[i])&#123; LIS[size++] = list[i]; // 제일 뒤에 붙이기&#125; 제일 뒤의 원소를 확인 했을 때, 넣을 원소보다 작은 경우에는 LIS 제일 뒤에 붙여넣습니다. 12345else&#123; int temp = Arrays.binarySearch(LIS,0, size, list[i]); // 삽입할 위치 if(temp &lt; 0) temp = -temp -1; LIS[temp] = list[i];&#125; 그렇지 않을 경우 넣을 원소를 LIS 리스트에서 찾아 확인 후 -인덱스를 주며 넣을 위치에다 바꿔치기를 합니다. 결과를 보면 아래와 같습니다. 12LIS : [2, 3, 5, 7, 10, 14, 0, 0, 0, 0]LIS의 개수 : 6 경로 구하기 이진탐색 먼저 코드로 확인해보도록 하겠습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Arrays;public class LIS_Binary_Path &#123; public static void main(String[] args) &#123; int[] list = &#123;8, 2, 4, 3, 6, 11, 7, 10, 14, 5&#125;; int[] LIS = new int[list.length]; // LIS로 사용가능한 숫자를 저장, index 저장 int[] path = new int[list.length]; // 경로를 역추적하기 위해 int size = 0; // LIS의 개수를 관리할 변수 path[size] = -1; // 첫번째 들어갈 수 이므로 -1을 저장 LIS[size++] = 0; // 첫번째 숫자의 index를 반영 for (int i = 1; i &lt; list.length; i++) &#123; // LIS 배열의 마지막 숫자와 수열값을 비교 if (list[LIS[size - 1]] &lt; list[i]) &#123; path[i] = LIS[size - 1]; // 해당 위치를 path[i]에 넣음 LIS[size++] = i; // 제일 뒤에 index 를 붙임 &#125; else &#123; int temp = binarySearch(list, LIS, 0, size, list[i]); // 넣을 위치를 확인 if (temp &lt; 0) temp = -temp - 1; path[i] = path[LIS[temp]]; // 덮어쓸 위치의 index를 내것으로 복사 LIS[temp] = i; &#125; &#125; System.out.println(\"LIS의 개수 : \" + size); StringBuilder lisPath = new StringBuilder(); for (int i = LIS[size - 1]; i != -1; i = path[i]) &#123; lisPath.insert(0, list[i] + \" \"); &#125; System.out.println(\"LIS의 경로 : \" + lisPath.toString()); &#125; private static int binarySearch(int[] a, int[] c, int fromIndex, int toIndex, int key) &#123; int low = fromIndex; int high = toIndex - 1; while (low &lt;= high) &#123; int mid = low + high &gt;&gt;&gt; 1; int midVal = a[c[mid]]; if (midVal &lt; key) &#123; low = mid + 1; &#125; else &#123; if (midVal &lt;= key) &#123; return mid; &#125; high = mid - 1; &#125; &#125; return -(low + 1); &#125;&#125; 위 코드가 좀 복잡해 보일 수 있는데, Binary Search 함수를 따로 구현한 이유는 LIS 리스트는 입력받은 list 배열의 Index를 저장했기 때문입니다. path라는 리스트를 초기 인덱스(-1)부터 값을 LIS에 넣을 때마다 path를 추가해주는 방식을 사용했습니다. 그 경로를 -1이 나올때까지 결과는 다음과 같습니다. 12LIS의 개수 : 6LIS의 경로 : 2 3 6 7 10 14 이렇게 LIS(최장 증가 수열)에 대해서 알아 보았습니다.그럼 관련 알고리즘 문제 링크를 걸어드리며 마무리 짓도록 하겠습니다. 감사합니다.😁 관련 알고리즘 문제&nbsp;&nbsp;가장 긴 증가하는 부분 수열 &nbsp;&nbsp;전깃줄 &nbsp;&nbsp;전깃줄2","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://msnodeve.github.io/categories/algorithm/"},{"name":"skill","slug":"algorithm/skill","permalink":"https://msnodeve.github.io/categories/algorithm/skill/"},{"name":"lis","slug":"algorithm/skill/lis","permalink":"https://msnodeve.github.io/categories/algorithm/skill/lis/"},{"name":"dp","slug":"algorithm/skill/lis/dp","permalink":"https://msnodeve.github.io/categories/algorithm/skill/lis/dp/"},{"name":"binary search","slug":"algorithm/skill/lis/dp/binary-search","permalink":"https://msnodeve.github.io/categories/algorithm/skill/lis/dp/binary-search/"}],"tags":[{"name":"Algorithm","slug":"algorithm","permalink":"https://msnodeve.github.io/tags/algorithm/"},{"name":"LIS","slug":"lis","permalink":"https://msnodeve.github.io/tags/lis/"},{"name":"DP","slug":"dp","permalink":"https://msnodeve.github.io/tags/dp/"},{"name":"Binary Search","slug":"binary-search","permalink":"https://msnodeve.github.io/tags/binary-search/"}]},{"title":"SubSet(부분집합) - [Algorithm Skill]","slug":"algorithm-subset","date":"2020-05-23T09:43:26.000Z","updated":"2020-05-23T10:40:47.067Z","comments":true,"path":"2020/05/23/algorithm-subset/","link":"","permalink":"https://msnodeve.github.io/2020/05/23/algorithm-subset/","excerpt":"알고리즘의 기본적인 스킬을 다룹니다.이번 포스트에서는 알고리즘의 스킬 중 부분집합(Subset)에 대해서 알아 보려고 합니다. Subset BitMask","text":"알고리즘의 기본적인 스킬을 다룹니다.이번 포스트에서는 알고리즘의 스킬 중 부분집합(Subset)에 대해서 알아 보려고 합니다.목차는 다음과 같습니다. 1. 배열체크로 부분집합 구하기2. 비트마스크로 부분집합 구하기3. 관련 알고리즘 문제 Subset 배열체크부분집합이라는 단어는 고등학생때 많이 들어봤던 것 같습니다.일단 부분집합에 대해서 간단하게 알아 보도록 하죠.원소의 개수가 N일때, 부분집합의 개수는 2^N 입니다. 어떻게 그럴까요?1234567891011121314151617181920원소의 개수가 &#123;1, 2&#125; 라고할 때, 다음과 같이 부분 집합이 나올 수 있습니다.∅121, 2총 개수 : 4개원소의 개수가 &#123;1, 2, 3&#125; 라고할 때, 다음과 같이 부분 집합이 나올 수 있습니다.∅1231, 21, 32, 31, 2, 3총 개수 : 8개 그렇다면 이제 코드로 한번 작성해서 확인해 보도록 하겠습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class Subset_Visit &#123; static int N, totalCnt; // 원소의 개수, 총 경우의 수 static int[] inputs; static boolean[] visit; public static void main(String[] args) &#123; // 부분 집합을 구하기 위해서 원소 입력 Scanner sc = new Scanner(System.in); N = sc.nextInt(); inputs = new int[N]; visit = new boolean[N]; for (int i = 0; i &lt; N; i++) &#123; inputs[i] = sc.nextInt(); &#125; // 부분집합 시작 getSubset(0); // 출력 System.out.println(\"총 경우의 수 : \" + totalCnt); &#125; private static void getSubset(int cnt) &#123; // cnt가 원소의 개수만큼 돌았다면 if(cnt == N)&#123; totalCnt++; for (int i = 0; i &lt; N; i++) &#123; // 선택된 배열과 선택되지 않은 배열 출력 System.out.print((visit[i] ? inputs[i] : \"X\") + \"\\t\"); &#125; System.out.println(); return; &#125; // 현재 원소를 선택하고 다음 visit[cnt] = true; getSubset(cnt+1); // 현재 원소를 선택하지 않고 다음 visit[cnt] = false; getSubset(cnt+1); &#125;&#125; 위 코드를 실행해보면 아래와 같은 결과를 얻을 수 있습니다. 1234567891011121314151617181941 2 3 41 2 3 4 1 2 3 X 1 2 X 4 1 2 X X 1 X 3 4 1 X 3 X 1 X X 4 1 X X X X 2 3 4 X 2 3 X X 2 X 4 X 2 X X X X 3 4 X X 3 X X X X 4 X X X X 총 경우의 수 : 16 Subset 비트마스킹위에서 봤던 방문배열을 사용하게 되면 원소의 개수가 커졌을 때, 메모리 사용량이 많이 들어갈 수 있습니다.이번에는 비트마스킹을 이용해서 부분집합을 구해 보도록 하겠습니다. 1234567891011121314151617181920212223242526272829303132import java.util.Scanner;public class Subset_Bitmask &#123; static int N; // 원소의 개수 static int[] inputs; public static void main(String[] args) &#123; // 부분 집합을 구하기 위해서 원소 입력 Scanner sc = new Scanner(System.in); N = sc.nextInt(); inputs = new int[N]; for (int i = 0; i &lt; N; i++) &#123; inputs[i] = sc.nextInt(); &#125; // 부분집합 시작 getSubset(1 &lt;&lt; N); // 출력 System.out.println(\"총 경우의 수 : \" + (1 &lt;&lt; N)); &#125; private static void getSubset(int cnt) &#123; for (int flag = 0; flag &lt; cnt; flag++) &#123; // 0, 1, 2 ... flag 비트열 별로 원소 수만큼 각 자리 비트를 확인 for (int i = 0; i &lt; N; i++) &#123; System.out.print((((flag &amp; (1 &lt;&lt; i)) != 0) ? inputs[i] : \"X\") + \"\\t\"); &#125; System.out.println(); &#125; &#125;&#125; 위 코드의 실행 원리를 예시를 들며 설명 하겠습니다. 2개의 원소가 있다고 가정하면 총 경우의 수는 4.8을 Binary로 표현하면 1 0 0 이며, 4번을 돌며 각자리 입력 받은 원소의 개수만큼 비트 이동을 합니다. 1234567891011121314151617181920212223242526flag -&gt; 0 &#x3D; 0 0 일때i -&gt; 0 &#x3D; (1 &lt;&lt; 0) &#x3D; 01, flag &amp; i &#x3D;&gt; 0i -&gt; 1 &#x3D; (1 &lt;&lt; 1) &#x3D; 10, flag &amp; i &#x3D;&gt; 0따라서 X, X 로 표현 됩니다.flag -&gt; 1 &#x3D; 0 1 일때i -&gt; 0 &#x3D; (1 &lt;&lt; 0) &#x3D; 01, flag &amp; i &#x3D;&gt; 1i -&gt; 1 &#x3D; (1 &lt;&lt; 1) &#x3D; 10, flag &amp; i &#x3D;&gt; 0따라서 1, X 로 표현 됩니다.flag -&gt; 2 &#x3D; 1 0 일때i -&gt; 0 &#x3D; (1 &lt;&lt; 0) &#x3D; 01, flag &amp; i &#x3D;&gt; 0i -&gt; 1 &#x3D; (1 &lt;&lt; 1) &#x3D; 10, flag &amp; i &#x3D;&gt; 1따라서 X, 1 로 표현 됩니다.flag -&gt; 3 &#x3D; 1 1 일때i -&gt; 0 &#x3D; (1 &lt;&lt; 0) &#x3D; 01, flag &amp; i &#x3D;&gt; 1i -&gt; 1 &#x3D; (1 &lt;&lt; 1) &#x3D; 10, flag &amp; i &#x3D;&gt; 1따라서 1, 2 로 표현 됩니다. 위 코드를 실행해보면 아래처럼 결과가 나오는 것을 확인 할 수 있습니다. 123456721 2X X 1 X X 2 1 2 총 경우의 수 : 4 이렇게 부분집합에 대해서 알아 보았습니다.그럼 관련 알고리즘 문제 링크를 걸어드리며 마무리 짓도록 하겠습니다. 감사합니다.😁 관련 알고리즘 문제&nbsp;&nbsp;부분수열의 합","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://msnodeve.github.io/categories/algorithm/"},{"name":"skill","slug":"algorithm/skill","permalink":"https://msnodeve.github.io/categories/algorithm/skill/"},{"name":"subset","slug":"algorithm/skill/subset","permalink":"https://msnodeve.github.io/categories/algorithm/skill/subset/"},{"name":"bitmask","slug":"algorithm/skill/subset/bitmask","permalink":"https://msnodeve.github.io/categories/algorithm/skill/subset/bitmask/"}],"tags":[{"name":"Algorithm","slug":"algorithm","permalink":"https://msnodeve.github.io/tags/algorithm/"},{"name":"Subset","slug":"subset","permalink":"https://msnodeve.github.io/tags/subset/"},{"name":"Bit","slug":"bit","permalink":"https://msnodeve.github.io/tags/bit/"},{"name":"BitMask","slug":"bitmask","permalink":"https://msnodeve.github.io/tags/bitmask/"}]},{"title":"Recursive(재귀) - [Algorithm Skill]","slug":"algorithm-recursive","date":"2020-03-17T01:38:59.000Z","updated":"2020-05-05T05:23:05.208Z","comments":true,"path":"2020/03/17/algorithm-recursive/","link":"","permalink":"https://msnodeve.github.io/2020/03/17/algorithm-recursive/","excerpt":"알고리즘의 기본적인 스킬을 다룹니다.이번 포스트에서는 알고리즘의 스킬 중 재귀에 대해서 알아 보려고 합니다. Factorial Fibonacci Fibonacci Memoization Hanoi","text":"알고리즘의 기본적인 스킬을 다룹니다.이번 포스트에서는 알고리즘의 스킬 중 재귀에 대해서 알아 보려고 합니다.목차는 다음과 같습니다. 1. Factorial2. Fibonacci3. Fibonacci Memoization4. 관련 알고리즘 문제 Factorial 팩토리얼이라는 단어 많이 들어 보셨을 거라 생각합니다. 간단하게 다음과 같이 식을 세울 수 있습니다. n! = n * (n - 1)! 즉 예시를 들어 보면 다음과 같겠죠. 123450! &#x3D; 11! &#x3D; 1 * (1 - 1)! &#x3D; 1 * 0! &#x3D; 12! &#x3D; 2 * (2 - 1)! &#x3D; 2 * 1! &#x3D; 2...5! &#x3D; 5 * (5 - 1)! &#x3D; 5 * 4! &#x3D; 120 이렇게 n!을 코드로 한번 작성해 보고자 합니다. 아마 대표적인 재귀함수의 기본이지 않을까 싶습니다. 그럼 이제 코드를 한번 살펴 보도록 하겠습니다. 123456789101112131415161718192021222324import java.io.BufferedReader;import java.io.InputStreamReader;public class Factorial &#123; public static void main(String[] args) throws Exception &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); System.out.println(factorial(N)); &#125; // n! : n * (n-1)! // n! 계산 private static long factorial(int n) &#123; // 기저(재귀 탈출) if (n == 1) return 1; // 유도(파생) return n * factorial(n - 1); &#125;&#125; 이 코드에서 중요한 점은 재귀를 선언하면 무한 반복을 돌지않게 하기 위해 `기저 조건` 과 `다시 호출`을 하는 것이 가장 중요합니다. 재귀로 하고자 한다면 다음과 같이 선언을 한 뒤 사용하는 것이 좋을 것 같습니다. ~(개인적인 견해 입니다.)~ 1234567private static long factorial(int n)&#123; // 기저 조건 // 목표값에 도달했을 경우 빠져나가야 하기 때문입니다. // 파생 조건 // 목표값에 도달했지 않았을 경우 계속 돌아야 하기 때문입니다.&#125; 코드는 직접 한번 작성해보시기 바랍니다 😌 ## Fibonacci 피보나치 수열? 이 또한 많이 들어 보셨을 것 같습니다. 0번째 항을 0, 1번째 항을 1로 두고, 2번째 항부터는 바로 앞의 두 수를 더한 수가 됩니다. 16 번째 항까지만 나열해 보자면, 10, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987 규칙은 정말 간단하죠? 그럼 다음과 같이 식을 세울 수 있겠군요. f(n) = f(n - 1) + f(n - 2) 이제 우리가 해야할 일은 f(n) 의 값은 과연 몇일까?🤔 를 구하는 것 입니다.그럼 코드로 한번 구현을 해보도록 하겠습니다! 일단 위에서 말했지만, 재귀를 사용하기 위해서는 먼저 틀을 만들어야 합니다. 그리고 코드를 한번 볼까요? 123456789101112131415161718192021import java.io.BufferedReader;import java.io.InputStreamReader;public class Fibonacci &#123; public static void main(String[] args) throws Exception &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); System.out.println(fibonacci(N)); &#125; private static long fibonacci(int n) &#123; // 1. 우선 재귀를 그만둘 수 있는 기저 조건 // n이 0, 1일때 결과값은 0과 1이기 때문에 return n을 주었습니다. if (n &lt;= 1) &#123; return n; &#125; // 그렇다면 계속 파생조건을 주어야 겠죠. return fibonacci(n - 1) + fibonacci(n - 2); &#125;&#125; 계산이 어떻게 이루지는지 한번 보도록하겠습니다. 1234567891011N에 4를 입력했을 경우,1. fibonacci(4) 함수 호출2. n &lt;&#x3D; 1 아니기 때문에 return fibonacci(4 - 1) + fibonacci(4 - 2) 중에 첫번째 fibbonacci(4 - 1) 함수 호출3. n &lt;&#x3D; 1 아니기 때문에 return fibonacci(3 - 1) + fibonacci(3 - 2) 중에 첫번째 fibbonacci(3 - 1) 함수 호출4. n &lt;&#x3D; 1 아니기 때문에 return fibonacci(2 - 1) + fibonacci(2 - 2) 중에 첫번째 fibbonacci(2 - 1) 함수 호출5. n &lt;&#x3D; 1 이기때문에 return 1; 반환 후 4. 단계에서 두번째 fibonacci(2 - 2) 함수 호출 (현재 결과 값 1)6. n &lt;&#x3D; 1 이기때문에 return 0; 반환 후 3. 단계에서 두번째 fibonacci(3 - 2) 함수 호출 (현재 결과 값 1)7. n &lt;&#x3D; 1 이기때문에 return 1; 반환 후 2. 단계에서 두번째 fibonacci(4 - 2) 함수 호출 (현재 결과 값 2)8. n &lt;&#x3D; 1 아니기 때문에 return fibonacci(2 - 1) + fibonacci(2 - 2) 중에 첫번째 fibbonacci(2 - 1) 함수 호출9. n &lt;&#x3D; 1 이기때문에 return 1; 반환 후 8. 단계에서 두번째 fibonacci(2 - 2) 함수 호출 (현재 결과 값 3)10. n &lt;&#x3D; 1 이기때문에 return 0; 반환 후 최종 결과 값 3 반환 이해가 가지 않을 수 있습니다. 눈으로 보는 것 보다, 그리고 머리로 생각하는 것 보다 손으로 한번 써보는게 더 기억에 잘 남는다고 하니 한번 손으로 작성해보는 것도 좋은 방법인듯 합니다. 자! 여기서 잠깐… 혹시 N의 입력 값에 42이상의 값을 입력 해보셨나요? 결과 값이 조금 늦게 나오지 않았나요?음 늦게 나오지않았다면 정말 좋은 컴퓨터를 사용중이시네요 그럼 100을 입력해보시죠 하루를 걸려서라도 결과값은 나오지 않을거에요… 이거 왜이러는 걸까요? 그림을 한번 볼까요? 함수안에서 같은 함수를 호출(재귀)하게되면 콜스택에 쌓이게 됩니다. 그렇다면 위 그림을 비교해서 보자면 fibonacci(5) 즉, 5번째는 어떤 피보나치 수가 될지 확인해보기 위해서는 fibonacci(0)을 3번, fibonacci(1)을 5번, fibonacci(2)을 3번 … 이렇게 앞에 구했던 함수를 계속해서 함수 호출을 통해 5번째 피보나치 수를 구할 수 있게 됩니다. 그렇다면 이미 구했다면 더 이상 구하지 않게 하기 위해서는 어떤 방법이 필요할까요? 바로 Memoization! 을 이용하면 되겠습니다. Fibonacci Memoization우선 바로 코드를 보도록 하겠습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;public class FibonnaciMemoization &#123; static long[] call1, call2, memo; static long totalCnt1, totalCnt2; private static long fibo(int n) &#123; // 메모를 하지 않은 경우 call1[n]++; totalCnt1++; if (n &lt;= 1) return n; return fibo(n - 1) + fibo(n - 2); &#125; private static long fibo2(int n) &#123; // 메모를 한 경우 call2[n]++; totalCnt2++; if (n &lt;= 1) return n; // n항의 값을 계산한 적이 있었다면(메모 확인) 메모된 값 리턴 if (memo[n] != 0) &#123; return memo[n]; &#125; return memo[n] = fibo2(n - 1) + fibo2(n - 2); &#125; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); call1 = new long[N + 1]; call2 = new long[N + 1]; memo = new long[N + 1]; System.out.println(fibo2(N)); for (int i = 1; i &lt;= N; i++) &#123; System.out.println(\"fibo2(\" + i + \") : \" + call2[i]); &#125; System.out.println(\"fibo2 call count : \" + totalCnt2); System.out.println(\"============================\"); System.out.println(fibo(N)); for (int i = 1; i &lt;= N; i++) &#123; System.out.println(\"fibo(\" + i + \") : \" + call1[i]); &#125; System.out.println(\"fibo call count : \" + totalCnt1); System.out.println(\"============================\"); &#125;&#125; 이제 5 를 입력하고 돌려보시면 다음과 같은 결과를 보실 수 있습니다. 123456789101112131415161755fibo2(1) : 2fibo2(2) : 2fibo2(3) : 2fibo2(4) : 1fibo2(5) : 1fibo2 call count : 9&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;5fibo(1) : 5fibo(2) : 3fibo(3) : 2fibo(4) : 1fibo(5) : 1fibo call count : 15&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 같은 함수를 호출(재귀) 하면서 이전에 이미 구해놓았던 memo[-] 결과 값이 있다면 바로 리턴을 해주며 값을 계속 구하고 있는 모습을 보실 수 있습니다. 이렇게 돌려본 결과단순히 재귀를 돌렸을 경우 총 카운트는 15번메모이제이션을 한 뒤 돌렸을 경우 총 카운트는 9번으로 함수 콜스택을 줄여준 결과를 보여주고 있습니다. 이렇게 재귀함수에 대해서 알아 보았습니다.그럼 관련 알고리즘 문제 링크를 걸어드리며 마무리 짓도록 하겠습니다. 감사합니다.😁 관련 알고리즘 문제&nbsp;&nbsp;피보나치 수 &nbsp;&nbsp;피보나치 수 2","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://msnodeve.github.io/categories/algorithm/"},{"name":"skill","slug":"algorithm/skill","permalink":"https://msnodeve.github.io/categories/algorithm/skill/"},{"name":"recursive","slug":"algorithm/skill/recursive","permalink":"https://msnodeve.github.io/categories/algorithm/skill/recursive/"}],"tags":[{"name":"Algorithm","slug":"algorithm","permalink":"https://msnodeve.github.io/tags/algorithm/"},{"name":"Recursive","slug":"recursive","permalink":"https://msnodeve.github.io/tags/recursive/"},{"name":"Factorial","slug":"factorial","permalink":"https://msnodeve.github.io/tags/factorial/"},{"name":"Hanoi","slug":"hanoi","permalink":"https://msnodeve.github.io/tags/hanoi/"},{"name":"Fibo","slug":"fibo","permalink":"https://msnodeve.github.io/tags/fibo/"}]},{"title":"Hexo[Tranquilpeak] 사용방법","slug":"devlog-hexo-syntax","date":"2020-03-13T11:09:58.000Z","updated":"2020-03-17T08:15:32.830Z","comments":true,"path":"2020/03/13/devlog-hexo-syntax/","link":"","permalink":"https://msnodeve.github.io/2020/03/13/devlog-hexo-syntax/","excerpt":"Hexo[tranquilpeak 테마]이번 포스트에서는 Hexo 테마 중 Tranquilpeak, 어떻게 사용하는지에 대해 알아 보려고 합니다. Tag Alert Highlight Text","text":"이번 포스트에서는 Hexo 테마 중 Tranquilpeak, 어떻게 사용하는지에 대해 알아 보려고 합니다.목차는 다음과 같습니다. 1. Alert를 사용하는 방법!2. Highlight Text를 사용하는 방법! TagAlert Alert을 사용하는 방법 Info 알림을 사용하는 방법은 어떻게!? Success 알림을 사용하는 방법은 어떻게!? Warning 알림을 사용하는 방법은 어떻게!? Danger 알림을 사용하는 방법은 어떻게!? 아이콘이 거슬린다구요? 그럼 이렇게 표시는 어떨까요?? Info 알림을 사용하는 방법은 어떻게!? Success 알림을 사용하는 방법은 어떻게!? Warning 알림을 사용하는 방법은 어떻게!? Danger 알림을 사용하는 방법은 어떻게!? 우선 위와 같이 이 테마에서 가능한 md문법에 대해서 알아보도록 하겠습니다! 문법은 다음과 같습니다.123&#123;% alert [classes] %&#125;content&#123;% endalert %&#125; 파라미터 이름 값 info success Classes warning danger no-icon 위에 보시는 [classes]에 값을 넣고 작성하면 됩니다. 또한 표에서 보이는 5번째줄의 값(no-icon)은 icon을 보여주지 않고 Alert을 쓰는 방법입니다. 아래와 같이 쓰시면 됩니다. 123&#123;% alert info no-icon %&#125;Info 알림의 예시 코드&#123;% endalert %&#125; Info 알림 결과 ! Highlight Text Highlight Text을 사용하는 방법 Highlight Text는 형광펜을 그은 처럼 작성하는 것 입니다. 일단 예시를 보도록 하겠습니다. 1. 첫번째 형광펜은 기본 문법으로 2. 두번째 형광펜은 hexa color 문법으로 문법은 다음과 같습니다.123&#123;% hl_text [(classes | hexa code | rgb color | rgba color)] %&#125; content&#123;% endhl_text %&#125; 파라미터 이름 값 red green blue purple orange Classes yellow cyan primary success warning danger 위에 보시는 [(classes | hexa code)]에 값을 넣고 작성하면 됩니다. 또한 hexa code로도 작성할 수 있습니다. 사용 코드 예시는 아래와 같습니다. 123456&lt;p&gt;&lt;!-- basic code --&gt;1. &#123;% hl_text orange %&#125;첫번째 형광펜&#123;% endhl_text %&#125;은 기본 문법으로&lt;br&gt;&lt;!-- hexa code --&gt;2. &#123;% hl_text #00FFFF %&#125;두번째 형광펜&#123;% endhl_text %&#125;은 hexa color 문법으로&lt;/p&gt; 1. 첫번째 형광펜은 기본 문법으로 2. 두번째 형광펜은 hexa color 문법으로","categories":[{"name":"devlog","slug":"devlog","permalink":"https://msnodeve.github.io/categories/devlog/"},{"name":"hexo","slug":"devlog/hexo","permalink":"https://msnodeve.github.io/categories/devlog/hexo/"}],"tags":[{"name":"Hexo","slug":"hexo","permalink":"https://msnodeve.github.io/tags/hexo/"},{"name":"Syntax","slug":"syntax","permalink":"https://msnodeve.github.io/tags/syntax/"}]},{"title":"SSAFY 3기를 시작하며![합격 후기]","slug":"story-ssafy-3rd","date":"2019-12-24T12:04:36.000Z","updated":"2020-05-23T10:49:12.929Z","comments":true,"path":"2019/12/24/story-ssafy-3rd/","link":"","permalink":"https://msnodeve.github.io/2019/12/24/story-ssafy-3rd/","excerpt":"SSAFYSamsung Software Academy For Youth(삼성 청년 소프트웨어 아카데미) 서울 지역에 합격했습니다! 😘 그런 의미로 이야기를 한 번 써내려 가려 합니다.","text":"SSAFYSamsung Software Academy For Youth(삼성 청년 소프트웨어 아카데미) 서울 지역에 합격했습니다! 😘 그런 의미로 이야기를 한 번 써내려 가려 합니다. 2018년 1월부터 1기, 1,000명 선발을 시작으로 2022년까지 총 10,000명을 선발한다고 했습니다! (저는 사실 SSAFY를 3기 모집 1달 전에 알게 되었어요…) 이렇게 보니 규모가 정말 상당하다라고 생각이 듭니다. 또한 이 아카데미를 듣는 동안 달마다 삼성전자의 이름으로 100만원의 지원금(취업을 한 것이 아니라서, 취직 지원금 까지 신청이 가능하다고 합니다!)을 받을 수 있다고 하니 정말 대단해요!(역시 갓성전자…) 매년 두 기수 씩 교육생을 선발하는 중이며, 저는 2020년 2월 졸업 예정자로써 3기로 지원했으며 합격해서 교육을 듣게 되었습니다! 그럼 이제 SSAFY 3기 모집은 언제 였으며, 어떻게 준비를 했는지 이야기를 하겠습니다. 😊😊 이 포스트는 다음과 같은 흐름으로 정리해 보았습니다. 1. SSAFY를 어떻게 알게 되었나? 2. SSAFY 교육 과정 3. SSAFY 선발 과정 4. SSAFY.. 어떻게 들어갔는가? 5. SSAFY 결과 발표 SSAFY를 어떻게 알게 되었나주변 사람들로 인해 알게 되었어요. 제가 SSAFY를 알기전에 삼성 청년 SW 아카데미 모집 설명회가 있었다고 하던데… 미리 알았다면 아마 가보지 않았을까.. 눈물이 나네요😭😭 SSAFY 모집 설명회 일정 및 장소 이미지의 출처는 SSAFY(ssafy.com)에서 가져왔음을 밝힙니다. 위와 같이 10월 28일 부터 시작해 10월 31일 까지 4일에 걸쳐 진행되었다고 합니다! 장소 관계 신청으로 인해 조기 마감이 될 수 있다고 하더라구요…(참여하면 소정의 기념품 까지 챙겨줬는데😭😭) 참여한 것이 아니라 정확한 내용을 알려 드리기에는 한계가 있어 링크를 남겨 드립니다! SSAFY 3기 모집 설명회 : https://webstudynote.tistory.com/23 이전에 SSAFY 올레 행사도 있었다고 하네요! SSAFY 올레 행사 후기 : https://webstudynote.tistory.com/19 SSAFY 교육 과정 교육 장소 : 전국 4개 지역(서울, 대전, 광주, 구미) 교육 기간 : 2020년 1월 6일(월) ~ 2020년 12월 31일(목) (12개월) 12개월 기간동안의 세부 과정은 아래 사진과 같습니다. 이미지의 출처는 SSAFY(ssafy.com)에서 가져왔음을 밝힙니다. 기본과정(5개월) : 기본적으로 컴퓨터와 관련된 지식을 습득하기 위한 기간이라고 보시면 될것 같습니다! 이 과정에서는 Computational Thinking, Algorithm, Computer language(Python, Java, C++…등등) 을 배울 예정이라고 하네요! 1차 Job Fair(1개월) : 5개월동안 과정을 진행하면서 성적 우수자 대상으로 해외 연수도 보내주며, 필요한 사람에 한해 보충수업도 제공된다고 하네요. 심화과정(5개월) : 제일 중요한 시점인 것 같습니다. 기본 과정을 진행하면서 습득한 기본 지식을 통해 팀을 꾸려 하나의 프로젝트를 만들어 내는 과정이며, 프로젝트를 진행하기에 앞서 멘토들도 계신다고 하니 정말 좋은 시간이 될 것 같아요! 2차 Job Fair(1개월) : SSAFY의 마지막 1개월 활동.. SSAFY에서 개인별 맞춤형 경력 설계를 도와주며, 그에 맞게 취업 활동 및 채용 정보도 잘 알려 준다고 합니다! 이 과정까지 수료하게 된다면 뿌듯하고, 즐거울 것 같습니다(한편으로는 슬플 수도 있을 거 같군요😭) SSAFY에서 총 12개월의 교육 기간을 통해 &quot;문제해결 능력을 갖춘 차세대 SW인력 양성&quot; 을 목표로 정말 실전형 SW 개발자로 거듭날 수 있을 것 같습니다! 😁😁 SSAFY 선발 과정지원 자격 부터 선발 과정까지 자세하게 보도록 하겠습니다! 😉 지원 자격대상 연령 : 만 29세 이하 (1990. 1. 1 이후 출생자) 학력 : 국내외 4년제 대학(학사 이상) 졸업자 및 2020.2월 졸업 예정자(전공 무관) 재직 여부 현재 미 취업자 대상 인터뷰일(2019.12.3)부터 본 교육 시작일(2020.1.6) 전까지 재직(예정)자 지원불가(사업장 건강보험 및 국민연금 가입 여부기준) ※ 교육기간 중 취업할 경우, 해당 업체 입사전에 개별적으로 퇴소 기타사항 교육시작일 교육 입과 가능한 자 교육기간 중 통학 가능한 자(별도 숙소 제공 없음) 병역필 또는 면제자로 해외여행에 결격 사유가 없는 자 이미지의 출처는 SSAFY(ssafy.com)에서 가져왔음을 밝힙니다. 위와 같이 4단계에 걸쳐 선발을 합니다! 이제 자세하게 알려 드리도록 하겠습니다 😁 SSAFY 어떻게 들어갔는가지금부터는 위에서 봤던 4단계를 어떻게 진행했는지, 어떤 생각으로 면접을 봤는지, 알려드릴 수 있는 범위에서 자세하게 알려 드리도록 하겠습니다. 지원서를 접수하기 위해서는 SSAFY 홈페이지를 접속해 회원가입 및 로그인 후 온라인으로 지원서를 작성 할 수 있어요. (회원 인증 메일 확인 사진을 올리고 싶었으나, 제 3자에게 공개 또는 배포, 복사하는 것을 엄격히 금지하고 있어 올리지 못했습니다) Step 1) 지원서 접수(2019.10.28 ~ 11.11)지원서 접수는 SSAFY 홈페이지에서 지원 가능했습니다. 지원서에는 다음과 같은 항목을 작성해야 했어요. 기본 인적 사항 : 이름, 생년월일, 성별, 휴대폰 번호, 비상 연락처, 이메일, 주소 기재 학력 사항 : 최종 학력, 입학 일 및 졸업 일, 전공, 만점 기준 취득 학점 기재 경력 및 어학 사항 : 경력(인턴 및 근무 경험), 병역 사항, 어학(외국어 자격증 등) 어학 자격증은 1도 없었어요. 😭그렇지만 해본 경험은 죄다 적었습니다. 😎 희망지역 및 진단일정 : 1지망, 2지망(서울, 대전, 광주, 구미 중 택 2), SW적성 검사 진단 일정 선택 희망지역 - 1지망(서울 : 멀티캠퍼스 교육센터), 2지망(대전 : 삼성화재 유성연수원)진단일전 - 11월 16일 토요일 10시, 12시 이렇게 2개가 있었어요. SW관련 활동 : 학교에서 배운 전공 학점 및 공통 학점 기재, 교육이수 / 개발경험 / 수상경력 기재 저는 전공자여서 그런지 학점을 기재하고 보니 많았어요!(한 페이지를 꽉 채운느낌?)개발 경험과 수상 경력이 좀 있었던 것 같아요! 있는 대로 죄다 작성했습니다. 😎 에세이 : 2가지의 질문이 있었습니다! 두 질문 모두 500자 이상의 글을 작성해야 했습니다. 첫 번째는 SSAFY를 지원하게 된 동기, 향후 진로가 어떻게 될지두 번째는 외부 활동을 하며 겪었던 경험에 대해서 물어 보았습니다. 부가 인적 사항 : 장애인, 기초생활수급자 / 차상위계층 지원서에서 가장 중요한 항목이였던 에세이.질문의 의도를 캐치하면 다음과 같이 생각해 낼 수 있었어요!내가 왜 SSAFY가 필요한지, 커리큘럼을 따라하면 내 미래가 어떻게 변할지에 대한 질문 이였던 것 같아요! Step 2) SW 적성 진단(11.16)SW 적성 진단은 총 60분 동안 진행 되었으며, 2가지의 온라인 테스트로 진행 되었습니다. 첫 번째 수리/추리 논리 능력 진단(30분)으로 말 그대로 수리, 추리, 논리 능력을 진단 하는 내용을 다뤘습니다.두 번째 Computational Thinking 진단(30분)으로 문제를 컴퓨터 적인 생각으로 알고리즘을 생각해 진단 하는 내용을 다뤘습니다.(코딩 테스트가 아닌가 라는 생각으로 겁 먹었지만, 주어진 문제를 계산(알고리즘 풀이) 해 단답형 으로 제출하는 형식이였습니다, 그러나 1문제 맞췄나…😅😅) 문제 유출은 금지 사항이므로 어떤 문제가 나왔는지는 말씀 드리기가 어렵군요! 별도 사항 진단 하는 동안 총 10번의 재 접속 가능 2개의 진단 모두 응시 선택한 시간 외 접속 불가 실제 진단에 필요한 보안 프로그램을 설치 후 응시 운영체제(OS) : Windows 7, Windows 8, Windows 10해상도 : 1280 X 1024 이상 해상도 사용 권장웹 브라우저 : Internet Explorer(10이상), Google Chrome(최신버전)저는 mac 유저지만.. 이 날 만큼은 Windows로 진단을 봤어요! SW 적성 진단을 하면서 느낀점은 “아… 시작부터 불합격이 뜨겠구나” 이였지만 의외로 대부분의 지원자들이 합격 소식을 많이 들었어요! (그렇지만 저는 왜 합격한지 아직도 감사할 나름…!) Step 3) Interview(12.3 ~ 12.5)삼성 청년 SW 아카데미 3기 Interview 대상자로 선정 되었지만, 준비를 어떻게 해야 하는지 몰랐고, SSAFY가 시작한지 1년이 되었지만 정보도 많이 없었던 것 같습니다. 먼저 Interview를 보기 전 온라인 사전 학습을 해야 했었는데요! 이는 안내 메일로 왔습니다. 온라인 사전 학습으로 3가지의 과정 중 1개의 과정을 선택해 학습을 진행하는 방식입니다. IT 트랜드 창의/열정 SW기초 학습 기간 : 2019.11.23(토) 00:00 ~ 11.28(목) 23:59(총 6일) 지정된 학습 일정 이외에는 수강 불가 유의 사항으로는 사전 학습 미 수료의 경우에도 인터뷰는 참석 가능하지만, 선발 절차 중 하나 이므로, 성실히 수강 해야한다고 했습니다. 사전 학습을 통해 관련 분야의 지식을 얻을 수 있는 유익한 시간이 되었습니다. 이제 대망의 SSAFY Interview… 저는 12월 5일 Interview를 진행했습니다. ■ 일시 : 2019. 12. 5(목) 9:15 예상 소요 시간 : 대기시간 포함 2시간 30분저는 한 2시간 정도 걸렸던 것 같습니다! 😁 ■ 장소 서울 삼성 금융 캠퍼스 ■ 내용 Interview 안내 서류 확인 2차 SW 적성진단 (CBT) Interview ■ 복장 Interview에 적합한 단정한 복장 ■ 준비물 필수 서류 [원본] 신분증 (주민등록증/운전면허증/유효기간 만료전 여권에 한함) 4대보험 가입내역 확인서 (가입여부 확인) 졸업(예정)증명서, 성적 증명서 (석사인 경우 학사/석사 모두 지참) 기타 서류 : 대상자에 한함 (지원서에 기재한 자격 증빙) [원본] : 병적(병역) 증명서, 어학성적 증명서, 장애인/기초생활수급 대상 확인서 [사본 가능] : 자격증, 수상내역 확인증, 경력 증명서 等 기타 서류 ※ 서울 外 지역에서 참석하시는 분들께는 소정의 면접비 지급 예정 (지원서에 기재한 주소 기준)(면접비 까지주는 이런…😭😭) 처음 Interview 보는 것 치고는 분위기가 좋았습니다.본인이 SSAFY가 왜 필요한지, 어떤 것을 해보고 싶은지 IT 관련해서 얼마나 관심을 갖고 있는지를 묻는 정말 제게 궁금한 점을 물어보는 인터뷰 시간이였습니다. 😲😲 본 Interview 내용은 보안 서약서를 작성 했기 때문에 Interview 진행 했던 사항은 말씀 드릴 수 없습니다! SSAFY 결과 발표길고도 긴… 기대하고 기대했던 결과 발표의 기다림… 🙏🙏2주 정도 기다린 것 같아요. 문자 메세지로 홈페이지에서 Interview 결과를 확인 하라고 왔습니다.기다리던 순간… 결과 확인을 누르기가 정말 떨렸어요. 😭 이미지의 출처는 SSAFY(ssafy.com)에서 가져왔음을 밝힙니다. Interview 결과 합격이라는 단어를 본 순간 소리 질렀네요(당시 서울에서 부산으로 내려가는 기차 안이였는데 😂)입과, 입과포기 란이있었는데 보자마자 입과 누르고 확인 했습니다. 이미지의 출처는 SSAFY(ssafy.com)에서 가져왔음을 밝힙니다. 그리고 결과 발표 하루 뒤에 문자로 최종 합격 문자가 왔어요.알고있던 결과라도 다시 확인하니 너무 행복했습니다. 😍😍 부족한 부분이 있었는지 모르겠네요!! 이렇게 해서 SSAFY 3기를 합격하게 되었습니다!좀 더 궁금한 사항이 있다면 댓글로 남겨주세요! 썸네일의 출처는 SSAFY(ssafy.com)에서 가져왔음을 밝힙니다.","categories":[{"name":"story","slug":"story","permalink":"https://msnodeve.github.io/categories/story/"},{"name":"ssafy","slug":"story/ssafy","permalink":"https://msnodeve.github.io/categories/story/ssafy/"}],"tags":[{"name":"SSAFY","slug":"ssafy","permalink":"https://msnodeve.github.io/tags/ssafy/"},{"name":"Samsung","slug":"samsung","permalink":"https://msnodeve.github.io/tags/samsung/"},{"name":"Academy","slug":"academy","permalink":"https://msnodeve.github.io/tags/academy/"},{"name":"Software","slug":"software","permalink":"https://msnodeve.github.io/tags/software/"}]},{"title":"Linux, CentOS 작업 스케쥴러 - Crontab","slug":"devlog-linux-crontab","date":"2019-12-09T07:46:52.000Z","updated":"2020-03-17T08:15:44.314Z","comments":true,"path":"2019/12/09/devlog-linux-crontab/","link":"","permalink":"https://msnodeve.github.io/2019/12/09/devlog-linux-crontab/","excerpt":"Crontab?Cron 은 리눅스 에서 특정한 명령이나 스크립트를 지정한 날짜/시간에 자동으로 실행해 주는 스케쥴러 입니다. 주기적으로 시스템 백업 스크립트를 실행하는 등 시스템 관리자에 의해 많이 사용되며, 이외 반복적인 작업을 하기위해 사용될 수 있습니다.","text":"Crontab?Cron 은 리눅스 에서 특정한 명령이나 스크립트를 지정한 날짜/시간에 자동으로 실행해 주는 스케쥴러 입니다. 주기적으로 시스템 백업 스크립트를 실행하는 등 시스템 관리자에 의해 많이 사용되며, 이외 반복적인 작업을 하기위해 사용될 수 있습니다. Crontab 활용 용도 30분 단위로 이메일을 전송 할 때 매주 일요일 새벽 4시에 서버를 재 시작 할 때 위와 같이 반복적인 예약 작업이 필요할 때 다양하게 활용할 수 있는 도구 입니다. Install crontab - CentOSyum 을 통해 Crontab 을 설치합니다. 1$ yum -y install cronie Crontab 설치가 완료 되었다면, Crontab 서비스가 잘 작동 하고 있는지 확인합니다. 1234567$ systemctl start crond$ systemctl list-unit-filesUNIT FILE STATE...crond.service enabled... How to use crontab?Crontab 리스트 조회1$ crontab -l crontab에 등록된 스케쥴러 작업 리스트를 확인합니다. Crontab 편집1$ crontab -e crontab 예약 작업 리스트를 편집 할 수 있는 에디터가 실행 되며, 편집합니다. Crontab 리스트 삭제1$ crontab -r crontab에 등록된 모든 스케쥴러 작업 리스트를 삭제합니다. Crontab 작성 방법123456789* * * * * 수행할 명령어┬ ┬ ┬ ┬ ┬│ │ │ │ ││ │ │ │ ││ │ │ │ └───────── 요일 (0 - 6) (0:일요일, 1:월요일, 2:화요일, …, 6:토요일)│ │ │ └───────── 월 (1 - 12)│ │ └───────── 일 (1 - 31)│ └───────── 시 (0 - 23)└───────── 분 (0 - 59) crontab -e 명령어를 사용해 위와 같은 형식으로 스케쥴러를 등록합니다. Example crontab간단한 텍스트를 파일에 쓰는 것을 해보겠습니다. 1$ crontab -e crontab 편집기를 열고 작업을 등록합니다. 1* * * * * echo \"Hello 두번 개발하는 블로그\" &gt;&gt; ~/test.txt ESC + qw 저장하고 밖으로 빠져 나옵니다. 1분이 지나게 되면 root 경로에 test.txt 파일이 생긴 것을 볼 수 있으며, 파일 내부에는 Hello 두번 개발하는 블로그 라는 텍스트가 작성 되어 있는 것을 볼 수 있습니다. 다른 예제특정 시간에 실행 1 매주 일요일 새벽 4시 20분에 test! 텍스트를 root 경로 밑 test.txt 파일에 작성 120 4 * * 0 echo \"test!\" &gt;&gt; ~/test.txt 특정 시간에 실행 2 매주 화요일 오후 1시 30분, 40분, 50분에 test! 텍스트를 root 경로 밑 test.txt 파일에 작성 110,20,30 13 * * 2 echo \"test!\" &gt;&gt; ~/test.txt Crontab 작성 기호 종류1234* # 범위 내 모두 실행, # 나열된 숫자 중 일치하는 값에 실행- # 두 숫자 사이에 포함된 범위에 실행/ # 지정한 숫자에 실행","categories":[{"name":"devlog","slug":"devlog","permalink":"https://msnodeve.github.io/categories/devlog/"},{"name":"linux","slug":"devlog/linux","permalink":"https://msnodeve.github.io/categories/devlog/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://msnodeve.github.io/tags/linux/"},{"name":"CentOS","slug":"centos","permalink":"https://msnodeve.github.io/tags/centos/"},{"name":"Infra","slug":"infra","permalink":"https://msnodeve.github.io/tags/infra/"},{"name":"Cron","slug":"cron","permalink":"https://msnodeve.github.io/tags/cron/"},{"name":"Crontab","slug":"crontab","permalink":"https://msnodeve.github.io/tags/crontab/"}]},{"title":"Flask REST API CRUD Board Auth 그리고 암호화(5) - [Backend Framework]","slug":"flask-restapi-example5","date":"2019-08-06T04:32:06.000Z","updated":"2020-06-22T02:16:59.494Z","comments":true,"path":"2019/08/06/flask-restapi-example5/","link":"","permalink":"https://msnodeve.github.io/2019/08/06/flask-restapi-example5/","excerpt":"다섯번째 단계이번 포스트에서는 vscode 개발환경에서 Flask Framework Auth, 암호화에 대해서 알아보는 시간을 가져 보도록 하겠습니다. 플라스크 Flask vscode Framework 암호화 Auth","text":"INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5) 이번 포스트는 macOS Mojave 10.14.5 에서 수행된 작업입니다. 개발 환경 MacBook Pro (13-inch, 2017, Four Thunderbolt 3 Ports) Python 3.7 vscode Docker-Compose version 1.23.2, build 1110ad01 Authorization 붙이기 (PyJwt), Password 암호화먼저, 클라이언트 측에서 회원가입을 할 때, Password를 Database에 저장 때는 암호화 해서 넣어야 합니다(개발자가 사용자 비밀번호 까지 알아서 뭐 할려고?) 그러기 위해서는 Bcrypt를 사용해 암호화를 진행 할 것이며, 암호화 한 것을 Database에 저장하고, 사용자가 로그인 할 때, 서버에서 발급해주는 Token을 이용해 API를 사용할 것 입니다 Token이 없다면 API의 요청은 거절 하도록 만들 것 입니다 해봅시다! PyJwt 종속성을 설치합니다 1&gt; pipenv install PyJwt 데코레이터를 이용해서 구현한 API에 붙여 주도록 하곘습니다 12345678910111213141516171819202122232425262728293031323334353637383940# ./app/api/auth_type.pyimport jwtfrom flask import request, Responsefrom functools import wrapsSECERET_KEY = \"Secret Hellow\"ACCESS_TOKEN = &#123; 'Access Token': &#123; 'type': 'apiKey', 'in': 'header', 'name': 'Authorization' &#125;&#125;BASIC_AUTH = &#123; 'Basic Auth': &#123; 'type': 'basic', 'in': 'header', 'name': 'Authorization' &#125;,&#125;def confirm_token(f): @wraps(f) def decorated_function(*args, **kwargs): access_token = request.headers['Authorization'] if access_token is not None: try: payload = jwt.decode(access_token, SECERET_KEY, \"HS256\") except jwt.InvalidTokenError: payload = None if payload is None: return Response(status=401) user_id = payload[\"user_id\"] # 원하는 작업 else: return Response(status=401) return f(*args, **kwargs) return decorated_function REST API Documents에 Authorization을 보여주기 위해 위와 같은 코드를 작성하고,Token 발급을 위해 다음과 같이 코드를 작성하겠습니다 123456789101112131415# ./app/api/__init__.py\"\"\" API config file\"\"\"from flask_restplus import Apifrom app.users.views import API as users_apifrom app.posts.views import API as posts_apifrom app.api.auth_type import ACCESS_TOKEN, BASIC_AUTHREST_API = Api(authorizations=&#123;**ACCESS_TOKEN, **BASIC_AUTH&#125;)REST_API.add_namespace(users_api, '/user')REST_API.add_namespace(posts_api, '/post') 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# ./app/users/views.py\"\"\" User views file\"\"\"import jwtimport bcryptfrom http import HTTPStatusfrom flask import jsonify, make_responsefrom sqlalchemy.exc import SQLAlchemyErrorfrom flask_restplus import Namespace, Resource, reqparse, fieldsfrom app.users.models import Users, UsersSchemafrom app.api.database import DBfrom app.api.auth_type import SECERET_KEYAPI = Namespace('Users', description=\"User's RESTPlus - API\")USERS_SCHEMA = UsersSchema()@API.route('s')class UsersAuth(Resource): parser = reqparse.RequestParser() parser.add_argument('user_id', required=True, type=str, help=\"User's ID\", location='json') parser.add_argument('user_password', required=True, type=str, help=\"User's PW\", location='json') parser.add_argument('user_email', required=True, type=str, help=\"User's Email\", location='json') users_field = API.model('userRegister', &#123; 'user_id': fields.String, 'user_password': fields.String, 'user_email': fields.String &#125;) @API.doc('post') @API.expect(users_field) def post(self): args_ = self.parser.parse_args() password = args_['user_password'] hash_pw = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()) user = Users(args_['user_id'], hash_pw, args_['user_email']) return user.add(user, USERS_SCHEMA)@API.route('/auth')class UserAuth(Resource): parser = reqparse.RequestParser() parser.add_argument('user_id', required=True, type=str, help=\"User's ID\", location='json') parser.add_argument('user_password', required=True, type=str, help=\"User's PW\", location='json') user_login_field = API.model('userLogin', &#123; 'user_id': fields.String, 'user_password': fields.String &#125;) @API.doc('post') @API.expect(user_login_field) def post(self): args_ = self.parser.parse_args() try: user = Users.query.filter(Users.user_id == args_['user_id']).first() if bcrypt.checkpw(args_['user_password'].encode('utf-8'), user.user_password.encode('utf-8')): # token 발급 payload = &#123; 'user_id' : user.user_id &#125; token = jwt.encode(payload, SECERET_KEY, \"HS256\") body = jsonify(&#123;'access_token': token.decode('utf-8'),'user': user.id&#125;) if user: code = HTTPStatus.OK else: code = HTTPStatus.NOT_FOUND except SQLAlchemyError as err: body = jsonify(&#123;'message': str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) 발급한 Token을 클라이언트 측에서 저장을 한 뒤 발급받은 토큰을 서버로 Header 부분에 담아 데이터를 전송하여 맞으면 API요청을 받는 코드를 작성하도록 하겠습니다 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# /app/posts/views.py\"\"\" Posts view file\"\"\"from flask_restplus import Namespace, Resource, reqparse, fieldsfrom flask import jsonify, make_responsefrom http import HTTPStatusfrom sqlalchemy.exc import SQLAlchemyErrorfrom app.posts.models import Posts, PostsSchemafrom app.users.models import Users, UsersSchemafrom app.api.database import DBfrom app.api.auth_type import confirm_token, ACCESS_TOKEN, BASIC_AUTHAPI = Namespace('Posts', description=\"Post's REST API\")POSTS_SCHEMA = PostsSchema()@API.route('s')class Post(Resource): parser = reqparse.RequestParser() parser.add_argument('author_id', required=True, type=str, help=\"Post's author ID\", location='json') parser.add_argument('title', required=True, type=str, help=\"Post's title\", location='json') parser.add_argument('body', required=True, type=str, help=\"Post's body\", location='json') post_field = API.model('Post', &#123; 'author_id': fields.String, 'title': fields.String, 'body': fields.String &#125;) @API.doc('get') def get(self): try: posts = Posts.query.all() body = jsonify(POSTS_SCHEMA.dump(posts, many=True).data) if posts: code = HTTPStatus.OK else: code = HTTPStatus.NOT_FOUND except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) @API.expect(post_field) @confirm_token @API.doc('post', security=ACCESS_TOKEN) def post(self): args_ = self.parser.parse_args() post = Posts(author_id=args_['author_id'], title=args_['title'], body=args_['body']) return post.add(post, POSTS_SCHEMA)@API.route('/&lt;int:reqno&gt;')class PostItem(Resource): @confirm_token @API.doc('get', security=ACCESS_TOKEN) def get(self, reqno): try: post = DB.session.query(Posts).outerjoin( Users, Users.user_id == Posts.author_id).filter(Posts.id==reqno).first() body = POSTS_SCHEMA.dump(post).data if post: code = HTTPStatus.OK else: code = HTTPStatus.NOT_FOUND except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) Post Class의 post함수를 보게 되면 데코레이터로 confirm_token 을 붙인 것을 볼 수 있습니다 이 API로 요청이 왔을 때 먼저 토큰이 있는지 검사하고 통과 되면 Post함수를 실행하게 되는 구조입니다 실행을 해봅시다 1$ python manage.py run 아래와 같은 화면을 볼 수 있으며 각각 실행을 해보세요! 최종적인 폴더 구조는 다음과 같습니다 고생하셨습니다! 지금까지 따라와주셔서 정말 감사드리며 여기까지 하게 되면 Flask 프레임워크의 기본을 할 수 있게 된 것 입니다! INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"python","slug":"backend/framework/python","permalink":"https://msnodeve.github.io/categories/backend/framework/python/"},{"name":"flask","slug":"backend/framework/python/flask","permalink":"https://msnodeve.github.io/categories/backend/framework/python/flask/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Flask","slug":"flask","permalink":"https://msnodeve.github.io/tags/flask/"},{"name":"Python","slug":"python","permalink":"https://msnodeve.github.io/tags/python/"}]},{"title":"Flask REST API CRUD Board 만들기 MVC 그리고 REST API Swagger(4) - [Backend Framework]","slug":"flask-restapi-example4","date":"2019-08-05T04:07:25.000Z","updated":"2020-06-22T02:16:26.539Z","comments":true,"path":"2019/08/05/flask-restapi-example4/","link":"","permalink":"https://msnodeve.github.io/2019/08/05/flask-restapi-example4/","excerpt":"네번째 단계이번 포스트에서는 vscode 개발환경에서 Flask Framework MVC, Swagger API 문서 자동화에 대해서 알아보는 시간을 가져 보도록 하겠습니다. 플라스크 Flask vscode Framework Swagger MVC","text":"INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5) 이번 포스트는 macOS Mojave 10.14.5 에서 수행된 작업입니다. 개발 환경 MacBook Pro (13-inch, 2017, Four Thunderbolt 3 Ports) Python 3.7 vscode Docker-Compose version 1.23.2, build 1110ad01 RESTPlus 라이브러리를 사용해 REST API 만들기(Users Part)flask-restplus 종속성을 설치합니다 1$ pipenv install flask-restplus 이제 app에 설치한 RESTPlus를 달아 봅시다 1234567891011121314151617181920212223242526# ./app/__init__.py\"\"\" APP을 실행하기 위해 config file\"\"\"from flask import Flaskfrom app.api.database import DB, MAfrom app.api import REST_APIfrom app.constants import SQLALCHEMY_DATABASE_URI_FORMATdef create_app()-&gt;(Flask): \"\"\" create_app()을 호출하여 app을 초기화 \"\"\" app = Flask(__name__) app.app_context().push() app.config['SQLALCHEMY_DATABASE_URI'] = SQLALCHEMY_DATABASE_URI_FORMAT app.config['SQLALCHEMY_ECHO'] = True app.config['DEBUG'] = True DB.init_app(app) REST_API.init_app(app) MA.init_app(app) return app MVC 패턴을 이용해 User 부분을 작성합니다 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# ./app/users/views.py\"\"\" User views file\"\"\"from http import HTTPStatusfrom flask import jsonify, make_responsefrom sqlalchemy.exc import SQLAlchemyErrorfrom flask_restplus import Namespace, Resource, reqparse, fieldsfrom app.users.models import Users, UsersSchemafrom app.api.database import DBAPI = Namespace('Users', description=\"User's RESTPlus - API\")USERS_SCHEMA = UsersSchema()@API.route('s')class UsersAuth(Resource): parser = reqparse.RequestParser() parser.add_argument('user_id', required=True, type=str, help=\"User's ID\", location='json') parser.add_argument('user_password', required=True, type=str, help=\"User's PW\", location='json') parser.add_argument('user_email', required=True, type=str, help=\"User's Email\", location='json') users_field = API.model('Sign up', &#123; 'user_id' : fields.String, 'user_password' : fields.String, 'user_email' : fields.String &#125;) @API.doc('post') @API.expect(users_field) def post(self): args_ = self.parser.parse_args() user = Users(args_['user_id'], args_['user_password'], args_['user_email']) try: DB.session.add(user) DB.session.commit() body = jsonify(&#123;'users' : USERS_SCHEMA.dump(user).data&#125;) code = HTTPStatus.OK except SQLAlchemyError as err: DB.session.rollback() body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value)@API.route('/auth')class UserAuth(Resource): parser = reqparse.RequestParser() parser.add_argument('user_id', required=True, type=str, help=\"User's ID\", location='json') parser.add_argument('user_password', required=True, type=str, help=\"User's PW\", location='json') user_login_field = API.model('Sign in', &#123; 'user_id' : fields.String, 'user_password' : fields.String &#125;) @API.doc('post') @API.expect(user_login_field) def post(self): args_ = self.parser.parse_args() try: user = Users.query.filter(Users.user_id == args_['user_id']).first() body = jsonify(&#123;'user_id' : user.user_id&#125;) code = HTTPStatus.OK except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) Swagger를 달아 API를 호출 할수있는 Docs를 만듭시다 12345678# ./app/api/**init**.pyfrom flask_restplus import Apifrom app.users.views import API as users_apiREST_API = Api()REST_API.add_namespace(users_api, '/user') 앱을 한번 실행해 봅시다 1$ python manage.py run RESTPlus API 만들기(Posts Part)이전 포스트와 같이 Posts에 대한 Model을 만듭니다 1234567891011121314151617181920212223242526272829303132333435# ./app/posts/models.py\"\"\" Posts model file\"\"\"from app.api.database import DB, MAfrom marshmallow import Schema, fields, validatefrom app.users.models import Users, UsersSchemafrom sqlalchemy.sql import textclass Posts(DB.Model): __tablename__ = 'posts' __table_args__ = &#123;'mysql_collate': 'utf8_general_ci'&#125; id = DB.Column(DB.Integer, primary_key=True) author_id = DB.Column(DB.String(255), DB.ForeignKey(Users.user_id)) title = DB.Column(DB.String(512), nullable=False) body = DB.Column(DB.String(1024), nullable=False) author = DB.relationship('Users', uselist=False) created = DB.Column(DB.TIMESTAMP, server_default=text(\"CURRENT_TIMESTAMP\"), nullable=False) def __init__(self, author_id, title, body): self.author_id = author_id self.title = title self.body = bodyclass PostsSchema(MA.Schema): not_blank = validate.Length(min=1, error='Field cannot be blank') id = fields.Integer() author_id = fields.String(validate=not_blank) title = fields.String(validate=not_blank) body = fields.String(validate=not_blank) author = fields.Nested(UsersSchema) created = fields.String(validate=not_blank) MVC 패턴을 이용해 Posts 부분을 작성합니다 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# ./app/posts/views.py\"\"\" Posts view file\"\"\"from flask_restplus import Namespace, Resource, reqparse, fieldsfrom flask import jsonify, make_responsefrom http import HTTPStatusfrom sqlalchemy.exc import SQLAlchemyErrorfrom app.posts.models import Posts, PostsSchemafrom app.users.models import Users, UsersSchemafrom app.api.database import DBAPI = Namespace('Posts', description=\"Post's REST API\")POSTS_SCHEMA = PostsSchema()@API.route('s')class Post(Resource): parser = reqparse.RequestParser() parser.add_argument('author_id', required=True, type=str, help=\"Post's author ID\", location='json') parser.add_argument('title', required=True, type=str, help=\"Post's title\", location='json') parser.add_argument('body', required=True, type=str, help=\"Post's body\", location='json') post_field = API.model('Post', &#123; 'author_id': fields.String, 'title': fields.String, 'body': fields.String &#125;) @API.doc('get') def get(self): try: posts = Posts.query.all() body = jsonify(POSTS_SCHEMA.dump(posts, many=True).data) code = HTTPStatus.OK except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) @API.expect(post_field) @API.doc('post') def post(self): args_ = self.parser.parse_args() post = Posts(author_id=args_['author_id'], title=args_['title'], body=args_['body']) try: DB.session.add(post) DB.session.commit() body = jsonify(&#123;'post', POSTS_SCHEMA.dump(post).data&#125;) code = HTTPStatus.OK except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value)@API.route('/&lt;int:reqno&gt;')class PostItem(Resource): def get(self, reqno): try: post = DB.session.query(Posts).outerjoin( Users, Users.user_id == Posts.author_id).filter(Posts.id==reqno).first() body = jsonify(&#123;'post' : POSTS_SCHEMA.dump(post).data&#125;) code = HTTPStatus.OK except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) Swagger를 달아 API를 호출 할수있는 Docs를 만듭시다 123456789101112# ./app/api/__init__.py\"\"\" API config file\"\"\"from flask_restplus import Apifrom app.posts.views import API as posts_apiREST_API = Api()REST_API.add_namespace(users_api, '/user')REST_API.add_namespace(posts_api, '/post') MVC(Model, View, Controller) 분리12345678910111213141516171819202122232425262728293031323334# ./app/api/database.py\"\"\" Create db\"\"\"from flask import jsonifyfrom flask import make_responsefrom http import HTTPStatusfrom flask_sqlalchemy import SQLAlchemyfrom sqlalchemy.exc import IntegrityErrorfrom flask_marshmallow import MarshmallowDB = SQLAlchemy()MA = Marshmallow()class CRUD: body = '' status_code = HTTPStatus.NOT_IMPLEMENTED def add(self, resource, schema): try: DB.session.add(resource) DB.session.commit() self.body = jsonify(schema.dump(resource).data) self.status_code = HTTPStatus.OK except IntegrityError as err: DB.session.rollback() err_meg = str(err) self.body = jsonify(&#123;'error' : err_meg, 'type' : 'IntegrityError'&#125;) if \"Duplicate entry\" in err_meg: self.status_code = HTTPStatus.CONFLICT else: self.status_code = HTTPStatus.BAD_REQUEST return make_response(self.body, self.status_code) User, Post Model을 따로 빼 줍니다 1234567891011121314151617181920212223242526272829303132# ./app/users/models.py\"\"\" Users models file\"\"\"from sqlalchemy.sql import textfrom app.api.database import DB, MA, CRUDfrom flask_sqlalchemy import SQLAlchemyfrom marshmallow import Schema, fields, validateclass Users(DB.Model, CRUD): __tablename__ = 'users' __table_args__ = &#123;'mysql_collate': 'utf8_general_ci'&#125; id = DB.Column(DB.Integer, primary_key=True) user_id = DB.Column(DB.String(255), unique=True, nullable=False) user_password = DB.Column(DB.String(255), nullable=False) user_email = DB.Column(DB.String(255), nullable=False) created = DB.Column(DB.TIMESTAMP, server_default=text(\"CURRENT_TIMESTAMP\"), nullable=False) def __init__(self, user_id : str, user_password : str, user_email : str): self.user_id = user_id self.user_password = user_password self.user_email = user_emailclass UsersSchema(MA.Schema): not_blank = validate.Length(min=1, error='Field cannot be blank') id = fields.Integer(dump_only=True) user_id = fields.String(validate=not_blank) user_password = fields.String(validate=not_blank) user_email = fields.String(validate=not_blank) created = fields.String(validate=not_blank) 1234567891011121314151617181920212223242526272829303132333435# ./app/posts/models.py\"\"\" Posts model file\"\"\"from app.api.database import DB, MA, CRUDfrom marshmallow import Schema, fields, validatefrom app.users.models import Users, UsersSchemafrom sqlalchemy.sql import textclass Posts(DB.Model, CRUD): __tablename__ = 'posts' __table_args__ = &#123;'mysql_collate': 'utf8_general_ci'&#125; id = DB.Column(DB.Integer, primary_key=True) author_id = DB.Column(DB.String(255), DB.ForeignKey(Users.user_id)) title = DB.Column(DB.String(512), nullable=False) body = DB.Column(DB.String(1024), nullable=False) author = DB.relationship('Users', uselist=False) created = DB.Column(DB.TIMESTAMP, server_default=text(\"CURRENT_TIMESTAMP\"), nullable=False) def __init__(self, author_id, title, body): self.author_id = author_id self.title = title self.body = bodyclass PostsSchema(MA.Schema): not_blank = validate.Length(min=1, error='Field cannot be blank') id = fields.Integer() author_id = fields.String(validate=not_blank) title = fields.String(validate=not_blank) body = fields.String(validate=not_blank) author = fields.Nested(UsersSchema) created = fields.String(validate=not_blank) view 부분도 빼 줍시다 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# ./app/users/views.py\"\"\" User views file\"\"\"from http import HTTPStatusfrom flask import jsonify, make_responsefrom sqlalchemy.exc import SQLAlchemyErrorfrom flask_restplus import Namespace, Resource, reqparse, fieldsfrom app.users.models import Users, UsersSchemafrom app.api.database import DBAPI = Namespace('Users', description=\"User's RESTPlus - API\")USERS_SCHEMA = UsersSchema()@API.route('s')class UsersAuth(Resource): parser = reqparse.RequestParser() parser.add_argument('user_id', required=True, type=str, help=\"User's ID\", location='json') parser.add_argument('user_password', required=True, type=str, help=\"User's PW\", location='json') parser.add_argument('user_email', required=True, type=str, help=\"User's Email\", location='json') users_field = API.model('userRegister', &#123; 'user_id' : fields.String, 'user_password' : fields.String, 'user_email' : fields.String &#125;) @API.doc('post') @API.expect(users_field) def post(self): args_ = self.parser.parse_args() user = Users(args_['user_id'], args_['user_password'], args_['user_email']) return user.add(user, USERS_SCHEMA)@API.route('/auth')class UserAuth(Resource): parser = reqparse.RequestParser() parser.add_argument('user_id', required=True, type=str, help=\"User's ID\", location='json') parser.add_argument('user_password', required=True, type=str, help=\"User's PW\", location='json') user_login_field = API.model('userLogin', &#123; 'user_id' : fields.String, 'user_password' : fields.String &#125;) @API.doc('post') @API.expect(user_login_field) def post(self): args_ = self.parser.parse_args() try: user = Users.query.filter(Users.user_id == args_['user_id'], Users.user_password == args_['user_password']).first() body = jsonify(&#123;'user_id' : user.user_id&#125;) if user: code = HTTPStatus.OK else: code = HTTPStatus.NOT_FOUND except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# ./app/posts/views.py\"\"\" Posts view file\"\"\"from flask_restplus import Namespace, Resource, reqparse, fieldsfrom flask import jsonify, make_responsefrom http import HTTPStatusfrom sqlalchemy.exc import SQLAlchemyErrorfrom app.posts.models import Posts, PostsSchemafrom app.users.models import Users, UsersSchemafrom app.api.database import DBAPI = Namespace('Posts', description=\"Post's REST API\")POSTS_SCHEMA = PostsSchema()@API.route('s')class Post(Resource): parser = reqparse.RequestParser() parser.add_argument('author_id', required=True, type=str, help=\"Post's author ID\", location='json') parser.add_argument('title', required=True, type=str, help=\"Post's title\", location='json') parser.add_argument('body', required=True, type=str, help=\"Post's body\", location='json') post_field = API.model('Post', &#123; 'author_id': fields.String, 'title': fields.String, 'body': fields.String &#125;) @API.doc('get') def get(self): try: posts = Posts.query.all() body = jsonify(POSTS_SCHEMA.dump(posts, many=True).data) if posts: code = HTTPStatus.OK else: code = HTTPStatus.NOT_FOUND except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) @API.expect(post_field) @API.doc('post') def post(self): args_ = self.parser.parse_args() post = Posts(author_id=args_['author_id'], title=args_['title'], body=args_['body']) return post.add(post, POSTS_SCHEMA)@API.route('/&lt;int:reqno&gt;')class PostItem(Resource): def get(self, reqno): try: post = DB.session.query(Posts).outerjoin( Users, Users.user_id == Posts.author_id).filter(Posts.id==reqno).first() body = POSTS_SCHEMA.dump(post).data if post: code = HTTPStatus.OK else: code = HTTPStatus.NOT_FOUND except SQLAlchemyError as err: body = jsonify(&#123;'message' : str(err)&#125;) code = HTTPStatus.INTERNAL_SERVER_ERROR return make_response(body, code.value) 이제 최종적으로 실행을 해봅시다 1$ python manage.py run INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"python","slug":"backend/framework/python","permalink":"https://msnodeve.github.io/categories/backend/framework/python/"},{"name":"flask","slug":"backend/framework/python/flask","permalink":"https://msnodeve.github.io/categories/backend/framework/python/flask/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Flask","slug":"flask","permalink":"https://msnodeve.github.io/tags/flask/"},{"name":"Python","slug":"python","permalink":"https://msnodeve.github.io/tags/python/"}]},{"title":"Flask REST API CRUD Board ORM 그리고 Model(3) - [Backend Framework]","slug":"flask-restapi-example3","date":"2019-08-04T11:15:52.000Z","updated":"2020-06-22T02:15:21.404Z","comments":true,"path":"2019/08/04/flask-restapi-example3/","link":"","permalink":"https://msnodeve.github.io/2019/08/04/flask-restapi-example3/","excerpt":"세번째 단계이번 포스트에서는 vscode 개발환경에서 Flask Framework ORM, Model에 대해서 알아보는 시간을 가져 보도록 하겠습니다. 플라스크 Flask vscode Framework ORM Model","text":"INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5) 이번 포스트는 macOS Mojave 10.14.5 에서 수행된 작업입니다. 개발 환경 MacBook Pro (13-inch, 2017, Four Thunderbolt 3 Ports) Python 3.7 vscode Docker-Compose version 1.23.2, build 1110ad01 Model 만들기, ORM 적용SQLAlchemy, Marshmallow 종속성을 설치합니다 1$ pipenv install flask_sqlalchemy flask-marshmallow Flask-Migrate pymysql 환경변수를 작성합니다 1234567891011121314# ./app/constants.py 생성\"\"\" 상수 클래스\"\"\"SQLALCHEMY_DATABASE_URI = (\"mysql+pymysql://&#123;USER&#125;:&#123;PASSWORD&#125;@&#123;ADDR&#125;:&#123;PORT&#125;/&#123;NAME&#125;?charset=utf8\")SQLALCHEMY_DATABASE_URI_FORMAT = SQLALCHEMY_DATABASE_URI.format( USER=\"[사용자 ID]\", PASSWORD=\"[사용자 PW]\", ADDR=\"127.0.0.1\", PORT=3306, NAME=\"[사용할 DB]\" ) 이제 app에 설치한 SQLAlchemy, Marshmallow를 달아 봅시다 12345678910111213141516171819202122232425262728# ./app/__init__.py\"\"\" APP을 실행하기 위해 config file\"\"\"from flask import Flaskfrom app.api.database import DB, MAfrom app.constants import SQLALCHEMY_DATABASE_URI_FORMATdef create_app()-&gt;(Flask): \"\"\" create_app()을 호출하여 app을 초기화 \"\"\" app = Flask(__name__) app.app_context().push() app.config['DEBUG'] = True app.config['SQLALCHEMY_ECHO'] = True app.config['SQLALCHEMY_DATABASE_URI'] = SQLALCHEMY_DATABASE_URI_FORMAT DB.init_app(app) MA.init_app(app) @app.route('/') def root(): \"\"\" main page \"\"\" return \"Hello World!\" return app 1234567891011121314151617181920212223242526272829# ./manage.py\"\"\" APP manage file\"\"\"from flask_script import Managerfrom flask_migrate import Migrate, MigrateCommandfrom app import create_appfrom app.api.database import DBfrom app.users.models import Users, UsersSchemaAPP = create_app()MANAGER = Manager(APP)MIGRATE = Migrate(APP, DB)MANAGER.add_command('db', MigrateCommand)@MANAGER.commanddef run(): \"\"\" Command Application run \"\"\" APP.run()@MANAGER.commanddef out(): \"\"\" test command out method \"\"\" return \"Test command\"if __name__ == '__main__': MANAGER.run() Database에 User 모델을 ORM으로 설계합니다User 모델을 작성합니다 1234567891011121314151617181920212223242526272829303132# ./app/users/models.py\"\"\" Users models file\"\"\"from sqlalchemy.sql import textfrom app.api.database import DB, MAfrom flask_sqlalchemy import SQLAlchemyfrom marshmallow import Schema, fields, validateclass Users(DB.Model): __tablename__ = 'users' __table_args__ = &#123;'mysql_collate': 'utf8_general_ci'&#125; id = DB.Column(DB.Integer, primary_key=True) user_id = DB.Column(DB.String(255), unique=True, nullable=False) user_password = DB.Column(DB.String(255), nullable=False) user_email = DB.Column(DB.String(255), nullable=False) created = DB.Column(DB.TIMESTAMP, server_default=text(\"CURRENT_TIMESTAMP\"), nullable=False) def __init__(self, user_id, user_password, user_email): self.user_id = user_id self.user_password = user_password self.user_email = user_emailclass UsersSchema(MA.Schema): not_blank = validate.Length(min=1, error='Field cannot be blank') id = fields.Integer(dump_only=True) user_id = fields.String(validate=not_blank) user_password = fields.String(validate=not_blank) user_email = fields.String(validate=not_blank) created = fields.String(validate=not_blank) 1234567891011# ./app/api/database.py\"\"\" Create db\"\"\"from flask_sqlalchemy import SQLAlchemyfrom flask_marshmallow import MarshmallowDB = SQLAlchemy()MA = Marshmallow() 설계한 ORM을 데이터베이스에 적용 시킵니다 db라는 커맨드로 추가해줬으니 init으로 migrations 폴더를 생성합니다 1$ python manage.py db init 이렇게 해준 뒤 데이터베이스를 보게 되면 다음과 같은 화면을 볼 수 있습니다 이는 데이터베이스만 생성시키는 작업을 합니다 현재 모델에 대한 모든 변경 사항을 감지를 못하고, 스크립트를 검토해 Database에 적용 시킵니다 1$ python manage.py db migrate 이러면 테이블이 생긴 모습을 확인할 수 있습니다 ORM구조가 변경 될 경우데이터베이스 모델이 변경 될 때마다 migrate, upgrade를 해주어야 합니다테이블을 동기화 하기 위해서요 1$ python manage.py db upgrade 현재까지의 폴더 구조는 아래와 같습니다 INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"python","slug":"backend/framework/python","permalink":"https://msnodeve.github.io/categories/backend/framework/python/"},{"name":"flask","slug":"backend/framework/python/flask","permalink":"https://msnodeve.github.io/categories/backend/framework/python/flask/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Flask","slug":"flask","permalink":"https://msnodeve.github.io/tags/flask/"},{"name":"Python","slug":"python","permalink":"https://msnodeve.github.io/tags/python/"}]},{"title":"Flask REST API CRUD Board 만들기 설정 및 MySQL(2) - [Backend Framework]","slug":"flask-restapi-example2","date":"2019-08-01T01:56:00.000Z","updated":"2020-06-22T02:14:38.293Z","comments":true,"path":"2019/08/01/flask-restapi-example2/","link":"","permalink":"https://msnodeve.github.io/2019/08/01/flask-restapi-example2/","excerpt":"두번째 단계이번 포스트에서는 vscode 개발환경에서 Flask Framework 설정 및 MySQL에 관하여 알아보는 시간을 가져 보도록 하겠습니다. 플라스크 Flask vscode Framework MySQL 설정","text":"INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5) 이번 포스트는 macOS Mojave 10.14.5 에서 수행된 작업입니다. 개발 환경 MacBook Pro (13-inch, 2017, Four Thunderbolt 3 Ports) Python 3.7 vscode Docker-Compose version 1.23.2, build 1110ad01 Manager 사용하기12345678910111213141516171819# ./app/__init__.py\"\"\" APP을 실행하기 위해 config file\"\"\"from flask import Flaskdef create_app()-&gt;(Flask): \"\"\" create_app()을 호출하여 app을 초기화 \"\"\" app = Flask(__name__) app.app_context().push() @app.route('/') def root(): \"\"\" main page \"\"\" return \"Hello World!\" return app Flask-Script 종속성을 설치합니다 1$ pipenv install Flask-Script 12345678910111213141516171819202122232425# ./manage.py\"\"\" APP manage file\"\"\"from flask_script import Managerfrom app import create_app # app/__init__.py의 create_app() 함수 사용APP = create_app()MANAGER = Manager(APP)@MANAGER.commanddef run(): \"\"\" Command Application run \"\"\" APP.run()@MANAGER.commanddef out(): \"\"\" test command out method \"\"\" return \"Test command\"if __name__ == '__main__': MANAGER.run() 작성해 놓은 커맨드를 한번 확인해 볼까요? 12345678910111213$ python manage.pyusage: manage.py [-?] &#123;run,out,shell,runserver&#125; ...positional arguments: &#123;run,out,shell,runserver&#125; run Command Application run out test command out method shell Runs a Python shell inside Flask application context. runserver Runs the Flask development server i.e. app.run()# def out(), def run()에 대한 커맨드가 생긴 것을 볼 수 있습니다!optional arguments: -?, --help show this help message and exit 이제 실행을 다시 해볼까요? 1234567$ python manage.py run * Serving Flask app \"app\" (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on &lt;http://127.0.0.1:5000/$ (Press CTRL+C to quit) MySQL 사용하기 위한 작업Docker가 필요한 시점입니다 Docker를 설치해주세요Docker 설치 관련 포스트 123456789101112131415161718# ./docker-compose.yml 생성version: '3'services: # 쓰고자하는 서비스 mysql: # 사용자가 원하는 이름 image: mysql:5.7 # 이미지는 mysql 5.7을 다운받아 사용할 것 hostname: mysql container_name: mysql command: --default-authentication-plugin=mysql_native_password restart: always # 시스템을 다시 껐다 켜도 항상 재시작 ports: - \"3306:3306\" # 23306 포트로 접속하면 내부에서 3306포트로 전송 env_file: - ./confs/database/mysql/.env # 환경 변수들을 따로 지정해줘도 되지만 파일로 떼어놓음 volumes: - mysql:/var/lib/mysql # docker 접속후 이 위치로 마운트(destination)volumes: mysql: MySQL 환경 변수를 작성 하겠습니다 123456# ./confs/database/mysql/.env 생성MYSQL_DATABASE_USERNAME=[데이터 베이스 사용자 이름]MYSQL_ROOT_PASSWORD=[데이터 베이스 루트 비밀 번호]MYSQL_DATABASE=[생성할 데이터베이스 이름]MYSQL_PORT=3306 Docker로 MySQL 생성하고 접속하기docker-compose.yml 위치가 있는 곳에서 다음 명령어를 실행합니다 12$ docker-compose up -dCreating mysql ... done done 이라는 단어가 보인다면 성공적으로 MySQL Conatainer를 생성한 것입니다만약 실패했다면 3306 포트가 사용중이 아닌지 확인해 주세요!(또는 댓글로 알려주세요) MySQL WorkBench를 이용해서 접속하기 Successfully made the MySQL connection 뜬다면 접속 성공! 생성된 데이터베이스에 접속해보면 다음과 같은 화면을 볼수 있습니다 INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"python","slug":"backend/framework/python","permalink":"https://msnodeve.github.io/categories/backend/framework/python/"},{"name":"flask","slug":"backend/framework/python/flask","permalink":"https://msnodeve.github.io/categories/backend/framework/python/flask/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Flask","slug":"flask","permalink":"https://msnodeve.github.io/tags/flask/"},{"name":"Python","slug":"python","permalink":"https://msnodeve.github.io/tags/python/"}]},{"title":"Flask REST API CRUD Board 만들기 실행(1) - [Backend Framework]","slug":"flask-restapi-example1","date":"2019-07-30T06:26:28.000Z","updated":"2020-06-22T02:05:39.329Z","comments":true,"path":"2019/07/30/flask-restapi-example1/","link":"","permalink":"https://msnodeve.github.io/2019/07/30/flask-restapi-example1/","excerpt":"첫번째 단계이번 포스트에서는 vscode 개발환경에서 Flask Framework 프로젝트를 생성하고 실행해보는 시간을 가져 보도록 하겠습니다. 플라스크 Flask vscode Framework 프로젝트 생성하는 방법!","text":"INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5) 이번 포스트는 macOS Mojave 10.14.5 에서 수행된 작업입니다. 개발 환경 MacBook Pro (13-inch, 2017, Four Thunderbolt 3 Ports) Python 3.7 vscode Docker-Compose version 1.23.2, build 1110ad01 왜 Flask 프레임워크를 쓰려고 정했는가?Django보다 좀 더 경량화 된 프레임워크라고 보시면 됩니다 그리고 REST API를 경험해보기에 딱 적당한 프레임워크라고 생각 되었습니다 Pipfile 생성pipenv = pip + virtualenv 동시에 사용하고자, Python.org 에서 공식적으로 권장하는 Python 패키지 툴입니다 Pipfile을 생성합니다 1$ pipenv --three Pipfile 필요한 패키지 설치개발에 필요한 패키지 설치 1$ pipenv install pytest-cov pytest pylint --dev 배포에 필요한 패키지 설치 1$ pipenv install flask 그림을 보시면 개발에 필요한 패키지를 설치할 경우 [dev-packages]에 배포에 필요한 패키지를 설치할 경우 [packages] 에 라이브러리가 설치 된 모습을 확인할 수 있습니다 가상 환경 진입1234567$ vi .envrcexport PIPENV_VENV_IN_PROJECT=.esc + wq!$ direnv allow$ pipenv shell$ pipenv sync 위 환경 변수 파일을 allow 하지 않으면 다음과 같이 비슷한 곳에서 activate 됩니다 1❯ . /Users/seok/.local/share/virtualenvs/example2-CgPABPw3/bin/activate 정확하게 되었다면 다음 사진과 같은 모습을 볼 수 있습니다 초기 프로젝트 뼈대 구조아래와 같이 구조를 잡아 줍시다 간단하게 APP 실행12345678910111213141516# ./manage.py 생성 (manage.py의 코드는 임시로 작성해놓음)\"\"\" APP manage 파일\"\"\"from flask import FlaskAPP = Flask(__name__)@APP.route('/')def main(): return \"Hello World!\"if __name__ == '__main__': APP.run() 실행해 봅시다 1234567$ python manage.py * Serving Flask app \"manage\" (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: off * Running on &lt;http://127.0.0.1:5000/$ (Press CTRL+C to quit) Flask는 Port를 적어주지않으면 5000번 Port로 기본 설정이 됩니다 (포트를 변경하고 싶으면 APP.run(port=[Port]) 로 실행하면 됩니다) http://127.0.0.1:5000/ 로 접속 화면 INDEX Flask RESTPlus CRUD Board 만들기 실행 (1) Flask RESTPlus CRUD Board 만들기 설정 및 MySQL (2) Flask RESTPlus CRUD Board 만들기 ORM 그리고 Model (3) Flask RESTPlus CRUD Board 만들기 MVC 그리고 REST API Swagger (4) Flask RESTPlus CRUD Board 만들기 Auth 그리고 암호화 (5)","categories":[{"name":"backend","slug":"backend","permalink":"https://msnodeve.github.io/categories/backend/"},{"name":"framework","slug":"backend/framework","permalink":"https://msnodeve.github.io/categories/backend/framework/"},{"name":"python","slug":"backend/framework/python","permalink":"https://msnodeve.github.io/categories/backend/framework/python/"},{"name":"flask","slug":"backend/framework/python/flask","permalink":"https://msnodeve.github.io/categories/backend/framework/python/flask/"}],"tags":[{"name":"Backend","slug":"backend","permalink":"https://msnodeve.github.io/tags/backend/"},{"name":"Framework","slug":"framework","permalink":"https://msnodeve.github.io/tags/framework/"},{"name":"Flask","slug":"flask","permalink":"https://msnodeve.github.io/tags/flask/"},{"name":"Python","slug":"python","permalink":"https://msnodeve.github.io/tags/python/"}]}]}